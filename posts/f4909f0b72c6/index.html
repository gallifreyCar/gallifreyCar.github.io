<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统学习笔记（三）内存管理 | Gallifrey的计算机学习日记</title><meta name="keywords" content="操作系统"><meta name="author" content="Gallifrey"><meta name="copyright" content="Gallifrey"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存管理概念内存的基础知识什么是内存？有何作用？程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾 进程运行的基本原理 创建步骤编译：编译程序将用户源代码编译成若干目标模块 链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块 装入：由装入程序将装入模块装入内存运行 链接类型静态链接：程序运行之前，将库函数连接成一个完整的可执行程">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习笔记（三）内存管理">
<meta property="og:url" content="https://gallifrey.asia/posts/f4909f0b72c6/index.html">
<meta property="og:site_name" content="Gallifrey的计算机学习日记">
<meta property="og:description" content="内存管理概念内存的基础知识什么是内存？有何作用？程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾 进程运行的基本原理 创建步骤编译：编译程序将用户源代码编译成若干目标模块 链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块 装入：由装入程序将装入模块装入内存运行 链接类型静态链接：程序运行之前，将库函数连接成一个完整的可执行程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-11T03:17:31.000Z">
<meta property="article:modified_time" content="2022-05-11T03:17:31.000Z">
<meta property="article:author" content="Gallifrey">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/G.png"><link rel="canonical" href="https://gallifrey.asia/posts/f4909f0b72c6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c230ce935268bf5d115ac7b937399330";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"3MS49WD3QJ","apiKey":"6f663f260703f2b756d1c06b756e7611","indexName":"GAS","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统学习笔记（三）内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-11 11:17:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script async src="/js/weather.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.9.0/map/js/china.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Gallifrey的计算机学习日记" type="application/atom+xml">
</head><body><div id="loading-box"><div class="bb8-loadingWarp"><div class="loading-bb8"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/shizi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/steam/"><i class="fa-fw fab fa-steam"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-street-view"></i><span> 访客</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-globe"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://gallifrey.asia"><i class="fa-fw fas fa-globe-asia"></i><span> 国内镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://gallifreycar.github.io"><i class="fa-fw fas fa-globe-americas"></i><span> 国外镜像</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/toyhouse/"><i class="fa-fw fas fa-robot"></i><span> 模型屋</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Gallifrey的计算机学习日记</a><div id="he-plugin-simple"></div></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/steam/"><i class="fa-fw fab fa-steam"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-street-view"></i><span> 访客</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-globe"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://gallifrey.asia"><i class="fa-fw fas fa-globe-asia"></i><span> 国内镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://gallifreycar.github.io"><i class="fa-fw fas fa-globe-americas"></i><span> 国外镜像</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/toyhouse/"><i class="fa-fw fas fa-robot"></i><span> 模型屋</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统学习笔记（三）内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-11T03:17:31.000Z" title="发表于 2022-05-11 11:17:31">2022-05-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-11T03:17:31.000Z" title="更新于 2022-05-11 11:17:31">2022-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统学习笔记（三）内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h3><h4 id="什么是内存？有何作用？"><a href="#什么是内存？有何作用？" class="headerlink" title="什么是内存？有何作用？"></a>什么是内存？有何作用？</h4><p>程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的<strong>速度矛盾</strong></p>
<h4 id="进程运行的基本原理"><a href="#进程运行的基本原理" class="headerlink" title="进程运行的基本原理"></a>进程运行的基本原理</h4><p><img src="/posts/f4909f0b72c6/image-20210812090013283.png" alt="image-20210812090013283"></p>
<h5 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h5><p>编译：编译程序将用户源代码编译成若干目标模块</p>
<p>链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块</p>
<p>装入：由装入程序将装入模块装入内存运行</p>
<h5 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a>链接类型</h5><p>静态链接：程序运行之前，将库函数连接成一个完整的可执行程序</p>
<p>装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式</p>
<p>运行时动态链接：对于某些目标模块的链接，<strong>程序需要时才会对其链接</strong> ，便于修改和更新，便于实现对目标模块的共享</p>
<h4 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h4><ul>
<li><p>逻辑地址空间：即相对地址，链接程序依次按照各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间</p>
</li>
<li><p>物理地址空间：内存中物理单元的集合，是地址转换的<strong>最终地址</strong> ，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。</p>
</li>
<li>地址重定位：逻辑地址转换成物理地址的过程</li>
</ul>
<h3 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h3><h4 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h4><p>操作系统负责<strong>内存空间的分配与回收</strong></p>
<h4 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h4><p>操作系统需要提供某种技术从<strong>逻辑上</strong>对内存空间进行扩充</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑</strong>地址与<strong>物理</strong>地址的转换</p>
<p><img src="/posts/f4909f0b72c6/image-20210812090640684.png" alt="image-20210812090640684"></p>
<h5 id="绝对装入（单道程序阶段，无操作系统）"><a href="#绝对装入（单道程序阶段，无操作系统）" class="headerlink" title="绝对装入（单道程序阶段，无操作系统）"></a>绝对装入（单道程序阶段，无操作系统）</h5><p>装入时按照实际的内存地址，将程序和数据装入内存</p>
<p>优点：不需要对程序和数据的地址进行修改</p>
<p>缺点：只适用于单道程序环境</p>
<h5 id="可重定位装入（静态重定位）（早期多道批处理阶段）"><a href="#可重定位装入（静态重定位）（早期多道批处理阶段）" class="headerlink" title="可重定位装入（静态重定位）（早期多道批处理阶段）"></a>可重定位装入（静态重定位）（早期多道批处理阶段）</h5><p>此时采用的是模块与模块的相对地址，然后将程序和数据装入内存</p>
<p>装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，又被称为静态重定位</p>
<p>特点：作业装入必须要<strong>一次性全部装入</strong>，并且运行中作业<strong>不能在内存中移动</strong>，也不能申请内存空间</p>
<h5 id="动态运行时装入（动态重定位）（现代操作系统）"><a href="#动态运行时装入（动态重定位）（现代操作系统）" class="headerlink" title="动态运行时装入（动态重定位）（现代操作系统）"></a>动态运行时装入（动态重定位）（<strong>现代操作系统</strong>）</h5><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，<strong>当程序真正执行时才进行转换</strong></p>
<p>特点：需要<strong>重定位寄存器</strong>可以将程序分配到<strong>不连续</strong>的存储区中便于程序段的共享可以向用户提供更大的地址空间（地址空间大于存储空间）</p>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，<strong>互不干扰</strong></p>
<p><img src="/posts/f4909f0b72c6/image-20210812090631848.png" alt="image-20210812090631848"></p>
<ul>
<li><p>CPU中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的数据比较，<strong>判断是否越界</strong></p>
</li>
<li><p>重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）：重定位寄存器中包含最小物理地址值，界地址寄存器包含<strong>逻辑地址的最大值</strong></p>
<p>地址转换过程：逻辑地址-&gt;界地址寄存器-&gt;重定位寄存器-&gt;物理地址</p>
</li>
</ul>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>思想：将程序分为<strong>多个段</strong>（多个模块）。常用的段<strong>常驻内存</strong>，不常用的段在<strong>需要时调入</strong>内存</p>
<p>将用户空间分为<strong>一个</strong>固定区和<strong>若干</strong>覆盖区，活跃部分放在<strong>固定区</strong>，即将访问的段放在<strong>覆盖区</strong></p>
<p>特点：打破了必须将一个进程的全部信息装入主存后才能运行的限制，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存</p>
<p>缺点：操作系统自动覆盖，对用户<strong>不透明</strong>，增加用户编程负担</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>思想：内存空间紧张时，系统将内存中某些进程<strong>暂时换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入内存</strong>（进程在内存与磁盘间<strong>动态调度</strong>）</p>
<p>换出：将处于等待状态的程序从内存中转移到辅存</p>
<p>换入：把准备好竞争CPU运行的程序从辅存转移到内存</p>
<p>结构：把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分</p>
<p>文件区主要用于存放文件，主要追求存储<strong>空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配</strong>方式</p>
<p>对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区，主要追求<strong>换入换出速度</strong>，因此通常对换区采用<strong>连续分配</strong>方式</p>
<h4 id="交换存在的问题"><a href="#交换存在的问题" class="headerlink" title="交换存在的问题"></a>交换存在的问题</h4><p>备份存储，使用快速硬盘，要求存储空间足够大，并且能够对内存映像进行直接访问</p>
<p>转移时间和所交换的内存空间成正比</p>
<p>只有进程空闲状态才能将进程换出</p>
<p>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快</p>
<p>交换通常在有许多进程运行且内存吃紧时开始启动，系统负荷降低就暂停</p>
<p>普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用</p>
<h4 id="覆盖与交换区别"><a href="#覆盖与交换区别" class="headerlink" title="覆盖与交换区别"></a>覆盖与交换区别</h4><p>覆盖是在<strong>同一个程序</strong>或进程中的</p>
<p>交换是在<strong>不同进程（或作业）</strong>之间的</p>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>内存分为<strong>系统区</strong>和<strong>用户区</strong>，系统区仅供操作系统使用，通常在低地址部分，用户区为用户提供</p>
<p>优点</p>
<p>无须进行内存保护，不会出现越界异常</p>
<p>实现简单，<strong>无外部碎片</strong>，采用覆盖技术，不需要额外技术支持</p>
<p>缺点</p>
<p>只适用于<strong>单用户</strong>，单任务的操作系统</p>
<p>存在<strong>内部碎片</strong>，存储器<strong>利用率低</strong></p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>种类</p>
<p>分区大小相等：用一台计算机去控制多个相同对象的场合，缺乏灵活性</p>
<p>分区大小不等：划分为多个较小的分区，适量的中等分区和少量大分区</p>
<p>优点</p>
<p>适用于多道程序的存储，无外部碎片</p>
<p>缺点</p>
<p>程序太大，无法放入任何一个分区</p>
<p>主存利用率低，存在内部碎片</p>
<p>不能实现多进程共享一个主存区</p>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>在进程装入内存的时候，<strong>根据内存的大小</strong>动态的建立分区</p>
<p>优点：分区大小可以根据进程的实际情况进行分配</p>
<p>缺点：存在<strong>外部碎片</strong>，最后导致主存利用率下降――采用<strong>紧凑技术</strong>可以缓解这种缺陷</p>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>空闲分区按照地址递增的顺序进行查找，找到<strong>第一个</strong>满足要求的分区进行分配</p>
<p>优点：综合看性能最好。算法开销小，回收分区后一般<strong>不需要</strong>对空闲分区队列<strong>重新排序</strong></p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p><strong>按照容量递增</strong>的顺序进行查找分区，将第一个满足条件的进行分配</p>
<p>优点：可以尽可能多地留下大片的空闲区</p>
<p>缺点：性能较差，产生<strong>最多的外部碎片</strong>，回收分区后可能需要对空闲分区队列<strong>重新排序</strong></p>
<p>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p>
<h4 id="最坏适应算法（最大适应算法）"><a href="#最坏适应算法（最大适应算法）" class="headerlink" title="最坏适应算法（最大适应算法）"></a>最坏适应算法（最大适应算法）</h4><p>空闲分区<strong>按照容量递减</strong>的次序进行查找，第一个满足条件的进行分配</p>
<p>优点：可以<strong>减少难以利用的小碎片</strong></p>
<p>缺点：导致很快没有较大的内存块，性能很差―<strong>不利于大进程</strong>，算法开销大</p>
<h4 id="邻近适应算法（首次适应算法）"><a href="#邻近适应算法（首次适应算法）" class="headerlink" title="邻近适应算法（首次适应算法）"></a>邻近适应算法（首次适应算法）</h4><p>分配内存时从<strong>上次查找结束</strong>的位置开始继续查找</p>
<p>优点：算法开销小</p>
<p>缺点：会使<strong>高地址的大分区也被用完</strong></p>
<p>导致无论低地址、高地址部分的空闲分区都有<strong>相同的概率</strong>被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用</p>
<h3 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h3><p>允许一个程序分散的装入<strong>不相邻</strong>的内存分区</p>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>将主存空间划分为大小相等且<strong>固定的块</strong>，块相对较小，作为主存的基本单位，进程以块为单位进行空间申请</p>
<p>分页存储与固定分区技术很像，但是其分页相对于分区又<strong>很小</strong>，分页管理<strong>不会产生外部碎片</strong>，产生的内部碎片也非常的小</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="页面和页面大小"><a href="#页面和页面大小" class="headerlink" title="页面和页面大小"></a>页面和页面大小</h5><p>进程中的块=页</p>
<p>内存中的块=页框（页帧）</p>
<p>进程申请主存空间，为每个页面分配主存中可用页框，即<strong>页与页框一一对应</strong></p>
<h5 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h5><p>页号（有多少页的编号）+页内偏移（页内存了多少东西）</p>
<p><strong>页号</strong>= 逻辑地址/ 页面长度（取除法的整数部分）</p>
<p><strong>页内偏移量</strong>= 逻辑地址% 页面长度（取除法的余数部分）</p>
<p>页号= 110 / 50 = 2</p>
<p>页内偏移量= 110 % 50 = 10</p>
<p><strong>逻辑地址</strong>可以拆分为（页号，页内偏移量）</p>
<p>通过页号查询页表，可知页面在内存中的起始地址</p>
<p>页面在内存中的起始地址+页内偏移量= 实际的<strong>物理地址</strong></p>
<p><img src="/posts/f4909f0b72c6/image-20210813090321357.png" alt="image-20210813090321357"></p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>记录了<strong>页面</strong>和<strong>实际存放的内存块</strong>之间的<strong>映射关系</strong></p>
<p>为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般放在内存中</p>
<p>页表项：页号+物理内存中的块号（不要与地址结构搞混）页表项的物理内存块号+地址结构中的页内偏移=物理地址</p>
<h5 id="页面大小要适中"><a href="#页面大小要适中" class="headerlink" title="页面大小要适中"></a>页面大小要适中</h5><p>页面太小：进程页面数过多，页表过程，增加内存占用，降低硬件地址转换效率</p>
<p>页面太大：页内碎片过多，降低内存利用率</p>
<h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><p><img src="/posts/f4909f0b72c6/image-20210813090736007.png" alt="image-20210813090736007"></p>
<p><img src="/posts/f4909f0b72c6/image-20210813090837154.png" alt="image-20210813090837154"></p>
<p>页表项大小的设计应当尽量一页正好能装下所有的页表项</p>
<p>第一步：分好块，在第几块第几个（页号P和页内偏移量W）</p>
<p>第二部：去问一下我的新家在哪，获得新家块（去<strong>页表寄存器</strong>看页表起始地址和判断，查<strong>页表</strong>找到内存块号）</p>
<p>第三步：新家号，在加上偏移量，就算出物理地址（内存块号加页内偏移W得到物理地址）</p>
<h4 id="分页管理存在的问题"><a href="#分页管理存在的问题" class="headerlink" title="分页管理存在的问题"></a>分页管理存在的问题</h4><p>地址变换过程必须足够快，否则访存速率会降低</p>
<p>页表不能太大，否则会降低内存利用率</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M</p>
<p>页表的始址和页表长度放在进程控制块（PCB）中</p>
<p><img src="/posts/f4909f0b72c6/image-20210813091416469.png" alt="image-20210813091416469"></p>
<h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><p><strong>快表</strong>，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的<strong>高速缓存</strong>（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的<strong>页表常称为慢表</strong>。</p>
<p><img src="/posts/f4909f0b72c6/image-20210813091600804.png" alt="image-20210813091600804"></p>
<p>可优化方向：如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要<strong>两次访问内存</strong></p>
<p>访问一个逻辑地址的访存次数</p>
<p>基本地址变换机构（<strong>两次访存</strong>）</p>
<p>具有快表的地址变换机构</p>
<p>快表<strong>命中</strong>，只需<strong>一次访存</strong></p>
<p>快表<strong>未命中</strong>，需要<strong>两次访存</strong></p>
<h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><h4 id="单级页表存在的问题"><a href="#单级页表存在的问题" class="headerlink" title="单级页表存在的问题"></a>单级页表存在的问题</h4><p>要在所有的页表项都<strong>连续存放</strong>的基础上才能用这种方法找到页表项</p>
<p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此<strong>没有必要让整个页表都常驻内存</strong>。</p>
<h4 id="如何解决单级页表的问题？"><a href="#如何解决单级页表的问题？" class="headerlink" title="如何解决单级页表的问题？"></a>如何解决单级页表的问题？</h4><p>如果页数过多，就会导致页表也过多，那么我们可以考虑设置一个用来储存页表的页表（套娃）</p>
<p>逻辑地址空间格式=一级页号＋二级页号＋页内偏移</p>
<p>设计多级页表的时候，最后一定要保证顶级页表一定只有一个</p>
<p>建立多级页表的目的在于建立索引，不必浪费主存空间去储存无用的页表项，也不用盲目式的查询页表项</p>
<h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><h4 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h4><p>分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过硬件机制实现，对用户完全透明</p>
<p>分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要</p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>按照用户进程中的自然段划分逻辑空间</p>
<p>地址结构=段号S+段内偏移量w</p>
<p>页式系统中，页号和页内偏移对用户透明</p>
<p>段式系统中段号和段内偏移量必须由用户显示的提供</p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>每个进程都有一张逻辑空间与内存空间映射的段白，这个段表项对应进程的一段，段表项记录该段在内存中的始址和长度</p>
<p>段表内容=段号＋段长＋本段在主存中的地址</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>逻辑地址A中取出段号S和段内偏移量w</p>
<p>比较段号S和段表长度M，若S&gt;=M，则产生越界中断，否则继续执行</p>
<p>段号S对应的段表项地址=段表始址F+段号S*段表项长度，从该段表项中取出段长C，比较段内偏移量与C的大小判断是否出现越界取出段表项中该段的始址b，计算E=b+W，用得到的物理地址E去访问内存</p>
<h4 id="段的共享与保护"><a href="#段的共享与保护" class="headerlink" title="段的共享与保护"></a>段的共享与保护</h4><p>共享：两个作业的段表中响应表项指向被共享段的同一个物理副本来实现的纯代码或者可重入代码以及不可修改的数据可以被共享</p>
<p>保护机制：</p>
<p>存取控制保护</p>
<p>地址越界保护</p>
<h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p>页式存储有效的提高内存利用率，分段存储能反映程序的逻辑结构并有利于段的分享，将这两种方式结合一下</p>
<p>这种二者结合的方法经常在计算机理论中遇到</p>
<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>作业的地址空间首先被分成若干逻辑段，每段有自己的段号</p>
<p>每个段分成若千大小固定的页<br>对内存空间的管理仍然和分页存储管理一样</p>
<h4 id="地址结构-1"><a href="#地址结构-1" class="headerlink" title="地址结构"></a>地址结构</h4><p>段号S+页号P+页内偏移量w<br>为了实现地址变换，系统为每个进程建立了一张段表，每个分段有一个页表<br>一个进程中，段表只能有一个，页表可以有多个</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>不能被修改的代码称为纯代码或可重入代码（不属于临界资源）</p>
<h5 id="分段与分页的区别"><a href="#分段与分页的区别" class="headerlink" title="分段与分页的区别"></a>分段与分页的区别</h5><p>分页对用户不可见，分段对用户可见</p>
<p>分页的地址空间是一维的，分段的地址空间是二维的</p>
<p>分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</p>
<p>分段更容易实现信息的共享和保护（纯代码问重入代码可以共享）</p>
<h5 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h5><p>优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</p>
<p>缺点：不方便按照逻辑模块实现信息的共享和保护</p>
<h5 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h5><p>优点：很方便按照逻辑模块实现信息的共享和保护</p>
<p>缺点：如果段长过大，为其分配很大的连续空间会很不方便</p>
<p>段式管理会产生外部碎片</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><h5 id="一次性："><a href="#一次性：" class="headerlink" title="一次性："></a>一次性：</h5><p>作业必须一次性<strong>全部装入</strong>内存后，才能开始运行</p>
<p>作业很大无法装入则无法运行</p>
<p>大量作业要求运行时，由于内存不足，只能一部分作业先运行，导致多道程序度下降</p>
<h5 id="驻留性："><a href="#驻留性：" class="headerlink" title="驻留性："></a>驻留性：</h5><p>作业装入内存后，<strong>一直驻留在内存中</strong>，任何部分不会被换出。</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><h5 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h5><p>一条指令执行后，不就之后指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p>
<p>原因：程序中存在着大量的<strong>循环操作</strong></p>
<p>时间局部性通过将<strong>最近使用的指令</strong>和数据存储在<strong>高速缓冲存储器中</strong></p>
<h5 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h5><p>一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p>
<p>原因：指令通常是<strong>顺序存放</strong>，顺序执行的，数据一般也是以向量、数组、表等形式簇聚存储的</p>
<p>空间局部性使用较大的<strong>高速缓存</strong>，将预取机制继承到高速缓存控制逻辑中实现</p>
<h4 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h4><p>基于局部性原理，程序的一部分装入内存，一部分留在外存，<strong>需要的时候将外存内容调入内存</strong>，就好像产生了一个巨大的内存空间</p>
<h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p><strong>多次性</strong>：作业在运行时，分多次调入内存运行</p>
<p><strong>对换性</strong>：作业不必一直驻留内存，允许作业在运行过程中进行换进换出</p>
<p><strong>虚拟性</strong>：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量</p>
<h4 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h4><p>建立在离散分配的内存管理方式上</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>请求分页存储管理</p>
<p>请求分段存储管理</p>
<p>请求段页式存储管理</p>
<h5 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h5><p>一定容量的内存和外存</p>
<p>页表机制（或者段表机制）</p>
<p>中断机制</p>
<p>地址变换机制</p>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>请求分页存储管理与基本分页存储管理的主要区别</p>
<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p>
<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面<strong>是否已经调入内存</strong>；如果还没调入，那么也需要知道该页面在<strong>外存中存放的位置</strong>。</p>
<p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定<strong>到底换出哪个页面</strong>；有的页面<strong>没有被修改过</strong>，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面<strong>是否被修改的信息</strong>。</p>
<p>请求页表项增加了四个字段：是否已调；可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考入内存；页面调入内存后是否被修改过；页面在外存中的存放位置。</p>
<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>组成：页号、物理块号、状态位P、访问字段A、修改位M、外村地址</p>
<p>状态位：当前页是否已经调入内存</p>
<p>访问字段A：记录本页在一段时间内被访问的次数修改位M：记录本页是否被修改过</p>
<p>外存地址：指出该页在外存上的位置（通常是物理块号）</p>
<h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>当访问页面<strong>不在内存时就会产生缺页中断</strong></p>
<p>特点</p>
<p>指令执行期间产生中断，而不是指令执行之后产生中断和处理中断</p>
<p>—条指令在执行期间，可能产生多次缺页中断</p>
<h4 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>检索快表，找到访问页，修改页表项中的访问位，利用页表项中给出的物理块号和页内地址形成物理地址</p>
<p>没有找到改页的页表项，去内存中寻找页表，看该页是否已经调入内存，没有调入则产生缺页中断，请求从外存把该页调入内存</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><p>选择永不使用或者<strong>最长时间内</strong>不再访问的页面进行淘汰，但是现实中是无法预知的</p>
<p>优点：缺页率最小，性能最好</p>
<h4 id="先进先出页面置换算法（FIFO-）"><a href="#先进先出页面置换算法（FIFO-）" class="headerlink" title="先进先出页面置换算法（FIFO ）"></a>先进先出页面置换算法（FIFO ）</h4><p>优先淘汰<strong>最早进入</strong>的页面</p>
<p>优点：实现简单</p>
<p>缺点：与进程的实际运行规律不匹配</p>
<p>Belady异常：增大分配的物理块数但是故障数不减反增―只有先进先出算法会出现</p>
<h4 id="最近最久未使用（LRU-）置换算法"><a href="#最近最久未使用（LRU-）置换算法" class="headerlink" title="最近最久未使用（LRU ）置换算法"></a>最近最久未使用（LRU ）置换算法</h4><p>选择<strong>最近最长时间</strong>没有被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间</p>
<p>优点：性能好</p>
<p>缺点：实现<strong>复杂</strong>需要寄存器和栈的硬件支持LRU是堆栈类算法</p>
<h4 id="时钟（CLOCK）置换算法"><a href="#时钟（CLOCK）置换算法" class="headerlink" title="时钟（CLOCK）置换算法"></a>时钟（CLOCK）置换算法</h4><p>简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页<strong>被访问时，其访问位置为1</strong>。当需要淘汰一个页面时，只需检查页的访问位。<strong>如果是0，就选择该页换出</strong>；<strong>如果是1，则将它置为0</strong>，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</p>
<p>优点：性能接近于最佳置换算法</p>
<p>缺点：实现复杂开销大</p>
<h4 id="改进型CLOCK算法"><a href="#改进型CLOCK算法" class="headerlink" title="改进型CLOCK算法"></a>改进型CLOCK算法</h4><p>使用位（访问位）的基础上增加修改位</p>
<h5 id="扫描过程"><a href="#扫描过程" class="headerlink" title="扫描过程"></a>扫描过程</h5><p>扫描缓冲区，选择第一个使用位和修改位都为0的页面换出</p>
<p>第一步失败后，查找使用位为0，修改位为1的进行替换，对于每个跳过的帧，将使用位置为0</p>
<p>第二步失败后，指针回到初始地点且使用位（访问位）均为0，重复第一步</p>
<p>优点：相对于未改进型，节省了时间</p>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h4><p>给一个<strong>进程的分配的物理页框的集合</strong>就是这个进程的驻留集</p>
<p>分配给一个进程的的存储量越小，任何时候驻留在主存中的进程数就越多，可以提高处理机的时间利用率一个进程在主存中的页数过少，页错误率就会相对较高</p>
<p>页数过多，对进程的错误率也不会产生过多的影响</p>
<h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>每个进程分配固定物理块数，缺页的时候就进行换页</p>
<p>难以确定每个进程应该分配的物理块数</p>
<p>太多导致资源利用率下降太少导致<strong>频繁缺页中断</strong></p>
<h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>进程分配一定物理块，系统自身保留一定空闲物理块，如果进程缺页，就对该进程分配新的物理块</p>
<p>优点：最容易实现，动态调整物理块分配</p>
<p>缺点：如果盲目分配物理块，就会导致<strong>多道程序并发能力下降</strong></p>
<h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>根据进程的缺页情况，对物理块进行动态分配，如果频繁缺页，就对其多分配物理块，<strong>如果缺页率特别低，就减少其物理块</strong></p>
<p>优点：保持了系统的<strong>多道程序并发能力</strong></p>
<p>缺点：增大了开销，实现复杂</p>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>将预计不久被访问的页面调入，成功率约为50%</p>
<p>当进程提出缺页的时候，再按照一定策略进行调页</p>
<h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>特点：一次调入—页，调入/调出页面数多时会花费过多的I/O开销</p>
<h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><h5 id="拥有足够的对换空间"><a href="#拥有足够的对换空间" class="headerlink" title="拥有足够的对换空间"></a>拥有足够的对换空间</h5><p>可以全部从对换区调入所需页面，提高调页速度</p>
<h5 id="缺少足够的对换区空间"><a href="#缺少足够的对换区空间" class="headerlink" title="缺少足够的对换区空间"></a>缺少足够的对换区空间</h5><p>不会被修改的文件从文件区调入，可能被修改的部分换入对换区，以后再从对换区调入</p>
<p>原理：读速度比写速度块</p>
<h5 id="UNIX方式"><a href="#UNIX方式" class="headerlink" title="UNIX方式"></a>UNIX方式</h5><p>进程相关文件访问文件区，没有运行的页面从文件区调入，曾经运行过但又被换出的页面放在对换区</p>
<h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p><strong>刚换出的页面又要换入内存</strong></p>
<p>分配的物理页帧数不足（主要原因）</p>
<p>原因</p>
<p>置换算法不当</p>
<p>配给其他进程</p>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>某段时间内，<strong>进程要访问的页面集合</strong>。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>操作系统跟走每个进程的工作集，并为进程分配大于其工作集的物理块</p>
<p>落入工作集的页面需要调入驻留集中，落在工作集外面的页面可以从驻留集中换出</p>
<p>若还有空闲物理块，可以再调入一个进程到内存以增加多道程序数。</p>
<p>若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程，并将其页面调出并将其物理块分</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本文是b站王道考研操作系统视频的学习笔记，另外很感谢cen6667同学的给出的课程ppt和思维导图，下路是相关参考链接<br><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1YE411D7nH?p=1">王道计算机考研 操作系统_哔哩哔哩</a></div></p>
<div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/cen6667/408">课程ppt和思维导图 Github</a></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Gallifrey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gallifrey.asia/posts/f4909f0b72c6/">https://gallifrey.asia/posts/f4909f0b72c6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gallifrey.asia" target="_blank">Gallifrey的计算机学习日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatreward.webp" target="_blank"><img class="post-qr-code-img" src="/images/wechatreward.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/images/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/shizi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gallifrey</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/gallifreyCar"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/gallifreyCar" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:956465331@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/images/wechat.webp" target="_blank" title="Wechat"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">该站点还在修建中ing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%9F%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是内存？有何作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程运行的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">创建步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">链接类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.3.</span> <span class="toc-text">逻辑地址空间与物理地址空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">内存管理的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">内存空间的分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">内存空间的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%EF%BC%88%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%97%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">绝对装入（单道程序阶段，无操作系统）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%EF%BC%88%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%89%EF%BC%88%E6%97%A9%E6%9C%9F%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">可重定位装入（静态重定位）（早期多道批处理阶段）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5%EF%BC%88%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%89%EF%BC%88%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">动态运行时装入（动态重定位）（现代操作系统）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.2.4.</span> <span class="toc-text">内存保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">交换技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">交换存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">覆盖与交换区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E5%A4%A7%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">最坏适应算法（最大适应算法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">邻近适应算法（首次适应算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.</span> <span class="toc-text">基本分页存储管理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.6.1.</span> <span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">页面和页面大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E8%A6%81%E9%80%82%E4%B8%AD"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">页面大小要适中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">基本地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">分页管理存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">1.7.2.</span> <span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.9.</span> <span class="toc-text">两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.1.</span> <span class="toc-text">单级页表存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">如何解决单级页表的问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">基本分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%8F%91%E7%82%B9"><span class="toc-number">1.10.1.</span> <span class="toc-text">出发点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">1.10.2.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">1.10.3.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.10.4.</span> <span class="toc-text">地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.10.5.</span> <span class="toc-text">段的共享与保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">段页式管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">1.11.1.</span> <span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.11.2.</span> <span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.11.3.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">分段与分页的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">分页管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">分段管理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">传统存储管理方式的特征、缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%EF%BC%9A"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">一次性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E6%80%A7%EF%BC%9A"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">驻留性：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">局部性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">时间局部性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">空间局部性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">虚拟存储器的定义和特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">虚拟内存技术的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">硬件支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.3.</span> <span class="toc-text">缺页中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO-%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">先进先出页面置换算法（FIFO ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88LRU-%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">最近最久未使用（LRU ）置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%EF%BC%88CLOCK%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">时钟（CLOCK）置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.5.</span> <span class="toc-text">改进型CLOCK算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">扫描过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.</span> <span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">驻留集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">页面分配、置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">固定分配局部置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">可变分配全局置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">可变分配局部置换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">2.4.3.</span> <span class="toc-text">调入页面的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">预调页策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">请求调页策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E9%A1%B5"><span class="toc-number">2.4.4.</span> <span class="toc-text">从何处调页</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%AF%B9%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">拥有足够的对换空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E5%B0%91%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%AF%B9%E6%8D%A2%E5%8C%BA%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">缺少足够的对换区空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UNIX%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">UNIX方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1"><span class="toc-number">2.4.5.</span> <span class="toc-text">抖动（颠簸）现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">2.4.6.</span> <span class="toc-text">工作集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">3.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/posts/cd20524d9846/" title="操作系统学习笔记（一）计算机系统概述">操作系统学习笔记（一）计算机系统概述</a><time datetime="2022-03-16" title="发表于 2022-03-16">2022-03-16</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/posts/b8f5718874ab/" title="操作系统学习笔记（二）进程管理">操作系统学习笔记（二）进程管理</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/posts/40891de7d6ba/" title="操作系统学习笔记（四）文件管理">操作系统学习笔记（四）文件管理</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/posts/4a2b19bd70d8/" title="操作系统学习笔记（五）IO管理">操作系统学习笔记（五）IO管理</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twilkoo-sljf-m3kv46ey3-ufovsmba.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twilkoo-sljf-m3kv46ey3-ufovsmba.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="/js/randombg.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api-pink-mu.vercel.app/api/?gallifreycar";
            var git_color =['#ffffff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="gallifreycar";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:120px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer" style="margin-inline:5px" title="主题版本Butterfly_v4.0.0"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站的评论区数据库和大部分API默认采用Vercel托管部署"><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20221706" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站已经在萌国备案，备案号萌ICP备20221706号"><img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20221706%E5%8F%B7-fe1384?style-flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAAByxJREFUSInl1nlwVeUZx/HPuTckkD0kQFiCEEIUlNUCAqKoSBV1AIt1ikpVLFbLONjWGUXbmWrbweJMy7hUxbbTjsUq6KCiWEvr0kE2WVK2QCKBJCxJgEASsienfxwqMob+3Zm+f93z3vM+32f5vc9z+H9bwVcfOp/YQ+1prhhEZS1VDQzqQ1MjiQmIC5Liwm3lBWpqFimrulb/7A/067vM2IsOBZ2h8MhJQW6KMDNVsKeaizKEyUlsKueqgWJ39AMJF3QpDCNYr1SaEig/lWNX2Z1h6dH5/lVyGdVIZFf7MHo9bEfh9rCg/+8NyHlN77QTsnpQ0i2y08VK+BosfhbW0cHxqmSfFd9qW+l9Pi+5WltFdGTsOBbO5dJcdh3lN5+xff0Y2zuelXjRsyYUrjOu4BVJaavlpbWIJRBLOM+J81O95AAnTtM9vNHGknut3zdT48FutJE3koWTuG4oSXH+VsInX3B9IdcVUNfCuv08t4GjO6NspOa3BNcOXx1eOugVHQnrTMkTuyWrC/BjRZO9uPYTpw7HhTWkXcLd45l9GblpHD7NWzt5ZTMXZ/OdkTy+lvR07rmcmWffq6pn9W5e/oymfcT6kJbXHiydMyVYkL/x66n+ZMcctQfjhgxl6UIGZ3Ooltd2RIZqjqKRS0ew9cFIA1cO5urlLHuPZWsZPJiZw7gqn0VT2HCIR9+jvCQhfHPrLGyE2Hng2roBxHnmJoZnc9drbD3I6QaaWkjpSVoeu4+x5XB05qMDqCenHz37UHmcFRv54ZuMeoYrB/L0DPRgZ0WfrsXVKzPX3nYykrn3dUZl8+Q0Qox/gc/L6ZlKzxQefo+UROpa6Z4VCedkPd8YyJYHI3u5T/HAShZNQxsXZfR3pCtwRW066VEeOuIUVUf77+9jTw2pycTOJml7Je1t9EgiI5X2jkgyze1fCSSdtjhBiJCkpKyuI+5oTdAtkTCgVwrbKsl8ko6QjO40tZ67EpkpdIbRf20dkbPpPTjdwsSX6I5dJYy4hoQAaZQdDy4A1iEMI613T6LtBPXJpPakrjGqc1Y6CTFq62htJp5KRwPJKWSkU3WKiiPEEqO6xgM6oZmctJhDXYH7Z59xuCyKpK6R26ZE+ys3MWYoN1/Mc5uoqmbEQJ6fTc/ulJ3i/lUc+YIfzeKhKzjVHN31A3XRHddKSrf6/6DOV3VTcw1hVKfkxOhaPDAe1UwfwmNTqT1Drxw+nE9xNXetIjHG2vnoxoT+rNrN2Of58Rp6JZ+ldKes5kjX4G7dKuikpoERfaltYnQ/DOSS3hEAFk9lXQkLnmf7Ib65lPJT3HU1+46Tm8rYvgzKYVA2h+vQIMjvewHwdSN20MiOSmZczO4a1hSzYi77T7CiiPF5JMTZexjJ5OagkwNV9M+MnJ09nKU3smgyQ3PYWoEO4fUjii4QceJmevJuMeP6csUAln4atcbSGoqOUpjD30uZNwnpHNtN3lC+NZa1xeT34pGVTJ3PL9+Ohs6GQ8gVtHZs6VLVwZhBReGwoXvt3THM/hP0SWVnCR8f4PMjkffjB/DQS8waxpHFfFgaaeHZDRRtJn0yP5tF31ymFVJ2nN27GD66KBzca2/XEWdkUpD3Fmd4tYj0FMS54Q9UnuaDUv6yE/24ewWP/DU6N/d1fvousYEs28DyLVEvGDOAt/egmSkXv2VYn3NBfpXbua6J8hMFFvy2RHsL+57gmX+w/AN651PfEDWQzLRI+afqIqOxFDJT6Rbn9Bmad3PnTH5wIxOXkJTWGiz57hCDsyqDWVldRNzeyOh+paaPfpFKnvqQX88iZwDVx0lLJqUHbe3EkZ1Odm+yUqK2GHYKmhvIG8fyeTz9IY5x67jnFPapdPDkl6jzwEF9IDjZJlgwfbG+o2u8+g4rd7D/UYI41TXnevV5K4j2q6uESckUP8rvNrH6fUH/sRXB9AlPONMSDZ8uazwoi56JjEyvdftV88jinhf4uIzmJRQOoOYgja0RKAiIBZxpjvZH5tP0c97axcLlyBXOuWZemJTYFFbUCU+1dl3j8PGSyFhnJ7EkYcWh7/njqpep5xfzWTyZZ7dEg73xOJKiGqf3YenNLBjLTz7i539COg/OvSOYO2GFo/VRG0Zwe0YX4Ns3R7NXSCxBeM8IthXfZvGf3xCWc/kkXvg2vVP4YB/rDzC1gGlDo+50/xvs2khKPrNnzAzmTH5HbzR0fkkKro93Ab5vx9kfaGgT3lLA5EyWbRpoTdHbSreOppGJV/PwlRTksK+aZz5l6z+RLBgxaau5k2cJelTKzmRQMq0d51J8UxL+23d1TDTcj7WQllZu4YwxDo+eZc22X9mwd6gN65GIFmQzampxcMOoR1xeuMbpVoqromsXdG3+wmCiekNtfSSmiUNWu2zgap+WjlZW8X11TeNkpWwICvNfCm8u3Cmxg4PN0VdmEJw7/7+0/g32RaqCbhRecAAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站已经在工信部备案，备案号粤ICP备2022046410号-1"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2022046410%E5%8F%B7--1-e1d492?style=flat&amp;logo=data:image/png;base64,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" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="/js/swiperbdage_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>