<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gallifrey&#39;s Blog</title>
  
  <subtitle>个人文章归档</subtitle>
  <link href="http://101.43.65.22/atom.xml" rel="self"/>
  
  <link href="http://101.43.65.22/"/>
  <updated>2022-03-30T04:42:56.000Z</updated>
  <id>http://101.43.65.22/</id>
  
  <author>
    <name>Gallifrey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统学习笔记（一）</title>
    <link href="http://101.43.65.22/posts/4194d1de52bf/"/>
    <id>http://101.43.65.22/posts/4194d1de52bf/</id>
    <published>2022-03-16T04:28:25.000Z</published>
    <updated>2022-03-30T04:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统的概念，功能和目标"><a href="#操作系统的概念，功能和目标" class="headerlink" title="操作系统的概念，功能和目标"></a>操作系统的概念，功能和目标</h2><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><p>操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件。</p><h4 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h4><p>补充知识：进程是应该程序的执行过程，执行前需要将该程序放到内存中，才能CPU处理。</p><h5 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h5><ul><li>作为系统资源的管理者<ul><li>功能<ul><li>处理机管理</li><li>储存机管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>目标<ul><li>安全</li><li>高效</li></ul></li></ul></li><li>作为用户和计算机硬件之间的接口<ul><li>功能<ul><li>命令接口：允许用户直接使用<ul><li>联机命令接口：用户说一句，操作系统做一句（交互式命令接口）</li><li>脱机命令接口：用户说一堆，操作系统做一堆（批处理命令接口）</li></ul></li><li>程序接口：允许用户用过程序间接使用（系统调用&#x2F;广义指令）</li><li>GUI（图形用户界面）</li></ul></li><li>目标<ul><li>方便用户使用</li></ul></li></ul></li><li>作为最接近硬件的层次<ul><li>功能和目标<ul><li>需要实现对硬件机器的扩展</li><li>没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造橙功能更强，使用更方便的机器</li><li>通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机</li></ul></li></ul></li></ul><p><img src="/posts/4194d1de52bf/image-20220317144853609.png" alt="image-20220317144853609"></p><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><h4 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h4><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul><li><p>并发：指两个或者多个事件在同一个时间间隔内发生。这些事情宏观上同时发生的，但在微观上是交替发生的。</p><p>易混淆–并行：指两个或者多个事件在同一个时刻同时发生。</p></li><li><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</p><p>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行(这些程序微观上是交替执行的，但宏观上看起来就像在同时执行)</p><p>事实上，操作系统就是伴随着”多道程序技术“而出现的。因此，操作系统和程序并发是一起诞生的</p></li><li><p>当今的计算机，一般都是多核cpu，如4核cpu这就意味着同一个时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少</p></li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><ul><li>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</li><li>两种资源共享方式<ul><li>互斥共享：一个时间端只允许一个进程访问该资源</li><li>同时共享：允许一个时间段内由多个进程“同时”对它们进行访问（所谓的“同时”往往是宏观上的，但是微观上<strong>有可能</strong>是交替对该资源进行访问，即分时共享）</li></ul></li><li>并发与共享的关系：互为存在条件</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ul><li>虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</li><li>虚拟技术<ul><li>空分复用技术（如虚拟存储器技术）</li><li>时分复用技术（如虚拟处理器–cpu）</li></ul></li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</li><li>只有系统拥有并发性，才有可能导致异步性</li></ul><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul><li>理解并发和并发的区别</li><li>并发和共享互为存在条件</li><li>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特性</li></ul><h2 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h2><p><img src="/posts/4194d1de52bf/image-20220317203705558.png" alt="image-20220317203705558"></p><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><ul><li><p>人–字带机–计算机—字带机人</p></li><li><p>主要缺点：用户独占全机，人机速度矛盾导致资源利用率低</p></li></ul><h4 id="批次处理阶段–单道批处理系统"><a href="#批次处理阶段–单道批处理系统" class="headerlink" title="批次处理阶段–单道批处理系统"></a>批次处理阶段–单道批处理系统</h4><ul><li><p>引入脱机输入&#x2F;输出技术（利用磁带技术），并监督程序负责控制作业的输入，输出</p></li><li><p>人–自带机—外围机–磁带–计算机–磁带–……</p></li><li><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</p></li><li><p>主要缺点：内存中仅能由一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I&#x2F;O完成。资源利用率依然很低</p></li></ul><h4 id="批处理阶段–多道批处理系统"><a href="#批处理阶段–多道批处理系统" class="headerlink" title="批处理阶段–多道批处理系统"></a>批处理阶段–多道批处理系统</h4><ul><li>在磁带部分，每次往内存中输入多道程序</li><li>操作系统正式诞生，并引入中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行。</li><li>主要优点:多道程序并发执行，共享计算机资源。资源利用率大幅度提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</li><li>主要缺点：用户响应时间长，没有人机交互功能（用户提升自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul><li>分时操作系统：计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互</li><li>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li><li>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不能区分任务的紧急性。</li></ul><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><ul><li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。</li><li>在实时操作系统的控制下，计算机系统接收道外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</li><li>分类：<ul><li>硬实时操作系统：必须在绝对严格的规定时间内完成处理</li><li>软实时操作系统：能接受偶尔违反时间规定</li></ul></li></ul><h4 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h4><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件的共享）和各个计算机之间的通信。（如：Windows NT</li><li>分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由他们并行，协同完成这个任务。</li><li>个人计算机操作系统：如Windows xp，MacOs</li></ul><h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><p><img src="/posts/4194d1de52bf/image-20220318152656657.png"></p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>指令和代码的区别：代码——&gt;翻译——&gt;指令</p><p>指令就是处理器（CPU）能够识别，执行的最基本命令</p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h4><ul><li>特权指令：如内存清零指令（不允许用户程序使用）</li><li>非特权指令：如普通的运算指令</li></ul><h4 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h4><ul><li>用户态（目态）：此时CPU只能执行非特权指令</li><li>核心态（管态）：特权指令，非特权指令都可以执行</li></ul><p>Ps:用程序状态寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态</p><h4 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h4><ul><li>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态</li><li>应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</li></ul><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><ul><li>内核是计算机上配置的底层软件，是操作系统最基本，最核心的部分。</li><li>实现操作系统内核功能的那些程序就是内核程序。</li></ul><p><img src="/posts/4194d1de52bf/image-20220318155126326-16484908229091.png" alt="image-20220318155126326"></p><p><img src="/posts/4194d1de52bf/image-20220318155148226-16484908312752.png" alt="image-20220318155148226"></p><h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h4><ul><li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>只把最基本的功能保留在内核</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li></ul><p><img src="/posts/4194d1de52bf/image-20220318160402910.png" alt="image-20220318160402910"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p><img src="/posts/4194d1de52bf/image-20220318181900829.png" alt="image-20220318181900829"></p><h4 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h4><ul><li>为了解决早期计算机各个程序只能串行执行，系统利用率低的问题；人们发明了操作系统，引入中断机制，实现了多道程序并发执行</li><li>本质：发生中断就意味着需要操作系统介入，开展管理工作</li></ul><h4 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a>中断的概念和作用</h4><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中端发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><ul><li><p>发生了中断，就意味着需要操作系统的介入，开展管理工作。由于操作系统的管理工作（比如进程的切换，分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p></li><li><p>用户态—&gt;核心态 是通过中断实现的，并且中断是唯一途径。</p><p>核心态—&gt;用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为”用户态“</p></li></ul>]]></content>
    
    
    <summary type="html">基于b站王道考研--操作系统视频课程学习时写的随堂笔记，侵权即删。</summary>
    
    
    
    
    <category term="学习笔记" scheme="http://101.43.65.22/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构课设报告</title>
    <link href="http://101.43.65.22/posts/4fcdac8c8023/"/>
    <id>http://101.43.65.22/posts/4fcdac8c8023/</id>
    <published>2022-01-06T15:45:56.000Z</published>
    <updated>2022-03-30T04:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目一：迷宫求解"><a href="#项目一：迷宫求解" class="headerlink" title="项目一：迷宫求解"></a>项目一：迷宫求解</h2><h4 id="a-需求分析："><a href="#a-需求分析：" class="headerlink" title="a)需求分析："></a>a)需求分析：</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>可以输入一个任意大小的迷宫数据，用非递归的方法求出一条走出迷宫的路径，并将路径输出</p><h4 id="b-概要设计："><a href="#b-概要设计：" class="headerlink" title="b)概要设计："></a>b)概要设计：</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>我打算设计一个迷宫游戏，用不同的算法生成迷宫，再用不同算法作路径规划</li><li>非递归的方法排除dfs路径规划方法</li><li>制作成可视化的程序</li></ul><ul><li><p>实现BFS算法寻找迷宫终点</p></li><li><p>实现基本的地图及寻找路径可视化</p></li><li><p>实现prim迷宫生成算法</p></li><li><p>改进BFS算法</p></li><li><p>独立出地图绘制类，供不同算法使用</p></li><li><p>封装主地图类</p></li><li><p>封装节点类</p></li><li><p>启用Scene Builder工具编写界面-</p></li><li><p>实现基本的UI界面</p></li><li><p>封装所有页面，改写为ButtonChose类的方法，实现页面跳转</p></li><li><p>加入DFS迷宫生成算法</p></li></ul><ul><li>重构MainMap类及其子类</li><li>重构bfs寻路算法</li><li>加入AStar寻路算法</li><li>加入bfs寻路算法</li></ul><h5 id="项目整体的设置思路图"><a href="#项目整体的设置思路图" class="headerlink" title="项目整体的设置思路图"></a>项目整体的设置思路图</h5><p><img src="/posts/4fcdac8c8023/io-1-16414137320101.png" alt="io-1"></p><h5 id="一些数据结构设计图"><a href="#一些数据结构设计图" class="headerlink" title="一些数据结构设计图"></a>一些数据结构设计图</h5><p><img src="/posts/4fcdac8c8023/io6.drawio-164142402935115-164142404151216.png" alt="io6.drawio"></p><p><img src="/posts/4fcdac8c8023/io7.drawio-164142501839317.png" alt="io7.drawio"></p><h5 id="设计说明："><a href="#设计说明：" class="headerlink" title="设计说明："></a>设计说明：</h5><p>该项目被我设计了一个迷宫游戏，玩家可以通过选择界面对迷宫的大小尺寸，迷宫的生成方式，起点与终点，屏幕分辨率等等属性进行时设置</p><p>点击开始游戏后，游戏会根据玩家的设置根据相应算法生成迷宫，玩家可以通过aswd四个键位操作角色走迷宫。</p><p>玩家可以通过按键J来使用BFS算法实时实现路径规划（显示角色到终点的路径，实时运算）</p><p>玩家可以通过按键L来使用AStar算法实时实现路径规划（显示角色到终点的路径，实时运算）</p><p>玩家可以通过按键K来进行角色导航（显示角色到终点的行走动画，实时运算，默认BFS算法）</p><h5 id="算法的设计有："><a href="#算法的设计有：" class="headerlink" title="算法的设计有："></a>算法的设计有：</h5><ol><li>随机prim迷宫生成算法</li><li>随机dfs迷宫生成算法</li><li>AStar路径规划算法</li><li>BFS路径规划算法</li></ol><h5 id="用到的数据结构有："><a href="#用到的数据结构有：" class="headerlink" title="用到的数据结构有："></a>用到的数据结构有：</h5><ol><li>链表</li><li>队列</li><li>双端队列</li><li>栈</li><li>优先队列</li><li>广义表</li><li>数组</li><li>树</li></ol><h4 id="c）详细设计："><a href="#c）详细设计：" class="headerlink" title="c）详细设计："></a>c）详细设计：</h4><h5 id="地图的每个点–Node类的设计"><a href="#地图的每个点–Node类的设计" class="headerlink" title="地图的每个点–Node类的设计"></a>地图的每个点–Node类的设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> FValue;<span class="comment">//总代价</span></span><br><span class="line">    <span class="type">int</span> HValue;<span class="comment">//预估代价 当前点到终点的的代价</span></span><br><span class="line">    <span class="type">int</span> GValue;<span class="comment">//当前代价 当前点到起点的代价</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//x坐标，y坐标</span></span><br><span class="line">    <span class="type">int</span> pre;<span class="comment">//上个节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//编号</span></span><br><span class="line">    <span class="type">boolean</span> isVisited=<span class="literal">false</span>;<span class="comment">//是否访问</span></span><br><span class="line">    <span class="type">int</span> value=<span class="number">1</span>;<span class="comment">//1是墙，0是路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pre)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.pre = pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPre</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPre</span><span class="params">(<span class="type">int</span> pre)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVisited</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isVisited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVisited</span><span class="params">(<span class="type">boolean</span> visited)</span> &#123;</span><br><span class="line">        isVisited = visited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHValue</span><span class="params">(Node end)</span> &#123;</span><br><span class="line">           HValue= Math.abs(x-end.getX())+Math.abs(y- end.getY());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGValue</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">        <span class="comment">//曼哈顿计算G值</span></span><br><span class="line">        HValue= Math.abs(x-start.getX())+Math.abs(y- start.getY());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFValue</span><span class="params">()</span> &#123;</span><br><span class="line">        FValue=HValue+GValue;</span><br><span class="line">        <span class="keyword">return</span> FValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(x+<span class="string">&quot; &quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迷宫生成算法接口的设计"><a href="#迷宫生成算法接口的设计" class="headerlink" title="迷宫生成算法接口的设计"></a>迷宫生成算法接口的设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMap</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Node start;<span class="comment">//起点</span></span><br><span class="line">    <span class="keyword">protected</span> Node end;<span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> col;<span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> row;<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">protected</span> Node nodeMap[][];<span class="comment">//地图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCol</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCol</span><span class="params">(<span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.col = col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRow</span><span class="params">(<span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.row = row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainMap</span><span class="params">(<span class="type">int</span> col, <span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.col = col;</span><br><span class="line">        <span class="built_in">this</span>.row = row;</span><br><span class="line">        nodeMap=<span class="keyword">new</span> <span class="title class_">Node</span>[row][col];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InitMap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置全为墙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; col;j++)&#123;</span><br><span class="line">                Node temp=<span class="keyword">new</span> <span class="title class_">Node</span>(i,j);</span><br><span class="line">                nodeMap[i][j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**随机生成起点和终点</span></span><br><span class="line"><span class="comment">         * 避免起点和终点靠得太近，将地图四分起点只在左上生成，终点在右下生成</span></span><br><span class="line"><span class="comment">         * 起点和终点不能同时在边界处</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        start=<span class="keyword">new</span> <span class="title class_">Node</span>(((<span class="type">int</span>)(Math.random()*row/<span class="number">2</span>+<span class="number">1</span>)),((<span class="type">int</span>)(Math.random()*col/<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//        System.out.println(&quot;开始点&quot;+start.getX()+&quot; &quot;+start.getY());</span></span><br><span class="line"></span><br><span class="line">        end=<span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">int</span>)((Math.random()*row)/<span class="number">2</span>+row/<span class="number">2</span>),(<span class="type">int</span>)((Math.random()*col))/<span class="number">2</span>+col/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMap</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStart</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(Node end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMap</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起点：&quot;</span>+start.getX()+<span class="string">&quot; &quot;</span>+start.getY());</span><br><span class="line">        System.out.println(<span class="string">&quot;终点：&quot;</span>+end.getX()+<span class="string">&quot; &quot;</span>+end.getY());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; col;j++)&#123;</span><br><span class="line">                System.out.print(nodeMap[i][j].value +<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作副本</span></span><br><span class="line">    <span class="keyword">public</span> MainMap <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MainMap</span> <span class="variable">clone</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MainMap</span>(col,row);</span><br><span class="line">        clone.InitMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                clone.nodeMap[i][j].setValue(nodeMap[i][j].getValue());</span><br><span class="line">                clone.nodeMap[i][j].setPre(nodeMap[i][j].getPre());</span><br><span class="line">                clone.nodeMap[i][j].setVisited(nodeMap[i][j].isVisited());</span><br><span class="line">                clone.nodeMap[i][j].setX(nodeMap[i][j].getX());</span><br><span class="line">                clone.nodeMap[i][j].setY(nodeMap[i][j].getY());</span><br><span class="line">                clone.nodeMap[i][j].setId(nodeMap[i][j].getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clone.end=end;</span><br><span class="line">        clone.start=start;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="地图接口设计"><a href="#地图接口设计" class="headerlink" title="地图接口设计"></a>地图接口设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMap</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Node start;<span class="comment">//起点</span></span><br><span class="line">    <span class="keyword">protected</span> Node end;<span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> col;<span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> row;<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">protected</span> Node nodeMap[][];<span class="comment">//地图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCol</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCol</span><span class="params">(<span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.col = col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRow</span><span class="params">(<span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.row = row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainMap</span><span class="params">(<span class="type">int</span> col, <span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.col = col;</span><br><span class="line">        <span class="built_in">this</span>.row = row;</span><br><span class="line">        nodeMap=<span class="keyword">new</span> <span class="title class_">Node</span>[row][col];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InitMap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置全为墙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; col;j++)&#123;</span><br><span class="line">                Node temp=<span class="keyword">new</span> <span class="title class_">Node</span>(i,j);</span><br><span class="line">                nodeMap[i][j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**随机生成起点和终点</span></span><br><span class="line"><span class="comment">         * 避免起点和终点靠得太近，将地图四分起点只在左上生成，终点在右下生成</span></span><br><span class="line"><span class="comment">         * 起点和终点不能同时在边界处</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        start=<span class="keyword">new</span> <span class="title class_">Node</span>(((<span class="type">int</span>)(Math.random()*row/<span class="number">2</span>+<span class="number">1</span>)),((<span class="type">int</span>)(Math.random()*col/<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//        System.out.println(&quot;开始点&quot;+start.getX()+&quot; &quot;+start.getY());</span></span><br><span class="line"></span><br><span class="line">        end=<span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">int</span>)((Math.random()*row)/<span class="number">2</span>+row/<span class="number">2</span>),(<span class="type">int</span>)((Math.random()*col))/<span class="number">2</span>+col/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMap</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStart</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(Node end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMap</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起点：&quot;</span>+start.getX()+<span class="string">&quot; &quot;</span>+start.getY());</span><br><span class="line">        System.out.println(<span class="string">&quot;终点：&quot;</span>+end.getX()+<span class="string">&quot; &quot;</span>+end.getY());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; col;j++)&#123;</span><br><span class="line">                System.out.print(nodeMap[i][j].value +<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作副本</span></span><br><span class="line">    <span class="keyword">public</span> MainMap <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MainMap</span> <span class="variable">clone</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MainMap</span>(col,row);</span><br><span class="line">        clone.InitMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                clone.nodeMap[i][j].setValue(nodeMap[i][j].getValue());</span><br><span class="line">                clone.nodeMap[i][j].setPre(nodeMap[i][j].getPre());</span><br><span class="line">                clone.nodeMap[i][j].setVisited(nodeMap[i][j].isVisited());</span><br><span class="line">                clone.nodeMap[i][j].setX(nodeMap[i][j].getX());</span><br><span class="line">                clone.nodeMap[i][j].setY(nodeMap[i][j].getY());</span><br><span class="line">                clone.nodeMap[i][j].setId(nodeMap[i][j].getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clone.end=end;</span><br><span class="line">        clone.start=start;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="路径规划算法接口设计"><a href="#路径规划算法接口设计" class="headerlink" title="路径规划算法接口设计"></a>路径规划算法接口设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title function_">find3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Prim随机生成地图算法原理与代码"><a href="#Prim随机生成地图算法原理与代码" class="headerlink" title="Prim随机生成地图算法原理与代码"></a>Prim随机生成地图算法原理与代码</h5><p>1.让迷宫全是墙.<br>2.选一个单元格作为迷宫的通路，然后把它的邻墙放入列表<br>3.当列表里还有墙时<br>    1.从列表里随机选一个墙，如果这面墙分隔的两个单元格只有一个单元格被访问过<br>        1.那就从列表里移除这面墙，即把墙打通，让未访问的单元格成为迷宫的通路<br>        2.把这个格子的墙加入列表<br>    2.如果墙两面的单元格都已经被访问过，那就从列表里移除这面墙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMap</span><span class="params">()</span>&#123;</span><br><span class="line">    InitMap();</span><br><span class="line">    nodeMap[<span class="number">1</span>][<span class="number">1</span>].setValue(<span class="number">0</span>);<span class="comment">//将起点变成路</span></span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Node&gt; listA=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Node&gt; listB= <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//待选路点进入链表</span></span><br><span class="line">    Node temp=nodeMap[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    listA.add(temp);</span><br><span class="line">    temp=nodeMap[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    listA.add(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listA.size()!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> randomNodeId=(<span class="type">int</span>)(listA.size()*Math.random());<span class="comment">//随机备选点作为A</span></span><br><span class="line">        Node randomA=listA.get(randomNodeId);<span class="comment">//随机路点A</span></span><br><span class="line">        listB=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将选路点A四周是路的进入备选池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:tempR=randomA.getX()-<span class="number">2</span>;tempC=randomA.getY();<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:tempR=randomA.getX()+<span class="number">2</span>;tempC=randomA.getY();<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:tempR=randomA.getX();tempC=randomA.getY()+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:tempR=randomA.getX();tempC=randomA.getY()-<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(tempC&lt;col&amp;&amp;tempC&gt;=<span class="number">0</span>&amp;&amp;tempR&gt;=<span class="number">0</span>&amp;&amp;tempR&lt;row))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否通路    加入临时通路备选池B</span></span><br><span class="line">            <span class="keyword">if</span>(nodeMap[tempR][tempC].getValue()==<span class="number">0</span>)&#123;</span><br><span class="line">                temp=nodeMap[tempR][tempC];</span><br><span class="line">                listB.add(temp);<span class="comment">// listB其实用数组更好 ，大小只有0-3 有1个是来的点，肯定访问过了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否为墙和A中是否包含该点加入 待选路点链表listA</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodeMap[tempR][tempC].getValue()==<span class="number">1</span>&amp;&amp;!listA.contains(nodeMap[tempR][tempC]))&#123;</span><br><span class="line">                    temp=nodeMap[tempR][tempC];</span><br><span class="line">                    listA.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> randomPass=(<span class="type">int</span>)(listB.size()*Math.random());<span class="comment">//随机备选点作为B</span></span><br><span class="line">        Node randomB=listB.get(randomPass);<span class="comment">//随机通路点</span></span><br><span class="line">        <span class="comment">//打通一条通路</span></span><br><span class="line">        nodeMap[randomA.getX()][randomA.getY()].setValue(<span class="number">0</span>);</span><br><span class="line">        nodeMap[(randomB.getX()+randomA.getX())&gt;&gt;<span class="number">1</span>][(randomA.getY()+randomB.getY())&gt;&gt;<span class="number">1</span>].setValue(<span class="number">0</span>);</span><br><span class="line">        listA.remove(randomA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保生成一个可达的终点</span></span><br><span class="line">    <span class="keyword">while</span> (nodeMap[end.getX()][end.getY()].getValue()==<span class="number">1</span>)&#123;</span><br><span class="line">        end=<span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">int</span>)((Math.random()*row)/<span class="number">2</span>+row/<span class="number">2</span>),(<span class="type">int</span>)((Math.random()*col))/<span class="number">2</span>+col/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DFS随机生成地图算法原理与代码"><a href="#DFS随机生成地图算法原理与代码" class="headerlink" title="DFS随机生成地图算法原理与代码"></a>DFS随机生成地图算法原理与代码</h5><p>1.将起点作为当前迷宫单元并标记为已访问<br>2.当还存在未标记的迷宫单元，进行循环<br>    1.如果当前迷宫单元有未被访问过的的相邻的迷宫单元<br>        1.随机选择一个未访问的相邻迷宫单元<br>        2.将当前迷宫单元入栈<br>        3.移除当前迷宫单元与相邻迷宫单元的墙<br>        4.标记相邻迷宫单元并用它作为当前迷宫单元<br>    2.如果当前迷宫单元不存在未访问的相邻迷宫单元，并且栈不空<br>        1.栈顶的迷宫单元出栈<br>        2.令其成为当前迷宫单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMap</span><span class="params">()</span>&#123;</span><br><span class="line">        InitMap();</span><br><span class="line">        LinkedList&lt;Node&gt; stackList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1.将起点作为当前迷宫单元并标记为已访问</span></span><br><span class="line">        Node current=nodeMap[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        nodeMap[<span class="number">1</span>][<span class="number">1</span>].setVisited(<span class="literal">true</span>);</span><br><span class="line">        stackList.add(current);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2.当还存在未标记的迷宫单元，进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(stackList.size()!=<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历4个方向</span></span><br><span class="line">            <span class="type">int</span> tempR=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> tempC=<span class="number">0</span>;</span><br><span class="line">            LinkedList&lt;Node&gt; AdjList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:tempR=current.getX()-<span class="number">2</span>;tempC=current.getY();<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:tempR=current.getX()+<span class="number">2</span>;tempC=current.getY();<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:tempR=current.getX();tempC=current.getY()+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:tempR=current.getX();tempC=current.getY()-<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理边界问题</span></span><br><span class="line">                <span class="keyword">if</span>(!(tempC&lt;col&amp;&amp;tempC&gt;<span class="number">0</span>&amp;&amp;tempR&gt;<span class="number">0</span>&amp;&amp;tempR&lt;row))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//未访问过的进入选择</span></span><br><span class="line">                <span class="keyword">if</span>(nodeMap[tempR][tempC].isVisited==<span class="literal">false</span>)&#123;</span><br><span class="line">                   AdjList.add(nodeMap[tempR][tempC]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          1.如果当前迷宫单元有未被访问过的的相邻的迷宫单元</span></span><br><span class="line">            <span class="keyword">if</span>(AdjList.size()!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//              1.随机选择一个未访问的相邻迷宫单元</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">randomDir</span> <span class="operator">=</span> (<span class="type">int</span>) ((AdjList.size() * Math.random()));</span><br><span class="line">                <span class="type">Node</span> <span class="variable">adjNode</span> <span class="operator">=</span> AdjList.get(randomDir);</span><br><span class="line"><span class="comment">//              2.将当前迷宫单元入栈</span></span><br><span class="line">                stackList.push(current);</span><br><span class="line"><span class="comment">//              3.移除当前迷宫单元与相邻迷宫单元的墙</span></span><br><span class="line">                adjNode.setValue(<span class="number">0</span>);</span><br><span class="line">                current.setValue(<span class="number">0</span>);</span><br><span class="line">                nodeMap[(adjNode.getX()+current.getX())&gt;&gt;<span class="number">1</span>][(adjNode.getY()+current.getY())&gt;&gt;<span class="number">1</span>].setValue(<span class="number">0</span>);</span><br><span class="line">                nodeMap[(adjNode.getX()+current.getX())&gt;&gt;<span class="number">1</span>][(adjNode.getY()+current.getY())&gt;&gt;<span class="number">1</span>].setVisited(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//              4.标记相邻迷宫单元并用它作为当前迷宫单元</span></span><br><span class="line">                adjNode.setVisited(<span class="literal">true</span>);</span><br><span class="line">                current=adjNode;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          2.如果当前迷宫单元不存在未访问的相邻迷宫单元，并且栈不空</span></span><br><span class="line">            <span class="keyword">if</span>(stackList.size()!=<span class="number">0</span>&amp;&amp;AdjList.size()==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//              1.栈顶的迷宫单元出栈</span></span><br><span class="line"><span class="comment">//              2.令其成为当前迷宫单元</span></span><br><span class="line">                 current=stackList.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确保生成一个可达的终点</span></span><br><span class="line">        <span class="keyword">while</span> (nodeMap[end.getX()][end.getY()].getValue()==<span class="number">1</span>)&#123;</span><br><span class="line">            end=<span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">int</span>)((Math.random()*row)/<span class="number">2</span>+row/<span class="number">2</span>),(<span class="type">int</span>)((Math.random()*col))/<span class="number">2</span>+col/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="BFS路径规划算法原理及代码"><a href="#BFS路径规划算法原理及代码" class="headerlink" title="BFS路径规划算法原理及代码"></a>BFS路径规划算法原理及代码</h5><p>从迷宫的入口开始，进行层次优先遍历（BFS，我更喜欢称之为层次优先遍历，因为这样更形象）。BFS遍历的关键就是需要用到一个队列，在这道题中，只需要从入口点出发，依次看下它的上下左右四个结点是否可以走，如果可以走，就立即把这个结点push到队列尾部，然后每次找的时候就是从队头取出一个点，依次看它的上下左右四个方向。遍历的路径的时候注意是从出口往入口找，所以需要用到一个栈保存一下路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">()</span>&#123;</span><br><span class="line">    Node start= mainMap.getStart();</span><br><span class="line">    Node end=mainMap.getEnd();</span><br><span class="line">    start.setPre(-<span class="number">1</span>);</span><br><span class="line">    nodeMap =mainMap.nodeMap;</span><br><span class="line"></span><br><span class="line">    linkedList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Node temp=<span class="literal">null</span>;</span><br><span class="line">    linkedList.offer(start);</span><br><span class="line">    rear++;</span><br><span class="line">    nodeMap[start.getX()][start.getY()].setValue(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!(front==rear)) &#123;</span><br><span class="line">        temp=linkedList.get(++front);</span><br><span class="line">        <span class="comment">//判断是不是终点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.getX() ==end.getX() &amp;&amp; temp.getY() ==end.getY()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历4个方向</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(temp.x, temp.y - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(temp.x, temp.y + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    temp2 =  <span class="keyword">new</span> <span class="title class_">Node</span>(temp.x - <span class="number">1</span>, temp.y);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(temp.x + <span class="number">1</span>, temp.y);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可走进队</span></span><br><span class="line">            <span class="keyword">if</span> (temp2.getX()&lt;mainMap.getCol()&amp;&amp;temp2.getX()&gt;<span class="number">0</span>&amp;&amp;temp.getY()&gt;<span class="number">0</span>&amp;&amp;temp2.getY()&lt;mainMap.getRow()&amp;&amp;nodeMap[temp2.getX()][temp2.getY()].getValue()==<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                linkedList.offer(temp2);</span><br><span class="line">                rear++;</span><br><span class="line">                temp2.id=linkedList.indexOf(temp2);</span><br><span class="line">                temp2.setPre(temp.getId());</span><br><span class="line">                nodeMap[temp2.getX()][temp2.getY()].setValue(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">find2</span><span class="params">()</span>&#123;</span><br><span class="line">    linkedList2=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    linkedList2.add(linkedList.get(front));</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (linkedList2.get(j).getPre()!=-<span class="number">1</span>)&#123;</span><br><span class="line">        linkedList2.add(linkedList.get(linkedList2.get(j).getPre()));</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    linkedList=linkedList2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title function_">find3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> time1=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println(time1);</span><br><span class="line">    find();</span><br><span class="line">    find2();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> time2=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println(time2);</span><br><span class="line">    System.out.println(time2-time1);</span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AStar路径规划算法原理及代码</p><p> 1.起点先添加到开启列表中<br> 2.开启列表中有节点的话，取出第一个节点，即最小F值的节点<br>  判断此节点是否是目标点，是则找到了，跳出<br>  根据此节点取得四个方向的节点，求出G，H，F值<br>  判断每个节点在地图中是否能通过，不能通过则加入关闭列表中，跳出<br>  判断每个节点是否在关闭列表中，在则跳出<br>  判断每个节点是否在开启列表中，在则更新G值，F值，还更新其父节点；不在则将其添加到开启列表中，计算G值，H值，F值，添加其节点<br> 3.把此节点从开启列表中删除，再添加到关闭列表中<br> 4.把开启列表中按照F值最小的节点进行排序，最小的F值在第一个<br> 5.重复2，3，4步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立一个优先队列</span></span><br><span class="line">        open=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(NodeComparator);</span><br><span class="line">        <span class="comment">//建一个保存链表</span></span><br><span class="line">        keptList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//起点的当前代价为0 预估代价用曼哈顿公式算</span></span><br><span class="line">        start=mainMap.getStart();</span><br><span class="line">        start.setPre(-<span class="number">1</span>);</span><br><span class="line">        nodeMap[start.getX()][start.getY()].setValue(-<span class="number">1</span>);</span><br><span class="line">        start.setGValue(start);</span><br><span class="line">        start.setHValue(end);</span><br><span class="line"></span><br><span class="line">        open.add(start);</span><br><span class="line"><span class="comment">//      开启列表中有节点的话，取出第一个节点，即最小F值的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int GValue=1;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(open.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node current=open.poll();</span><br><span class="line"></span><br><span class="line">            keptList.offer(current);<span class="comment">//保存下来，就可以找到路径了</span></span><br><span class="line">            current.id=keptList.indexOf(current);</span><br><span class="line"><span class="comment">//            判断此节点是否是目标点，是则找到了，跳出</span></span><br><span class="line">            <span class="keyword">if</span>(current.getX()==end.getX()&amp;&amp;current.getY()==end.getY()) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历4个方向</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(current.x, current.y - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(current.x, current.y + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        temp2 =  <span class="keyword">new</span> <span class="title class_">Node</span>(current.x - <span class="number">1</span>, current.y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        temp2 = <span class="keyword">new</span> <span class="title class_">Node</span>(current.x + <span class="number">1</span>, current.y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//可走进队</span></span><br><span class="line">                <span class="keyword">if</span> (temp2.getX()&lt;mainMap.getCol()&amp;&amp;temp2.getX()&gt;<span class="number">0</span>&amp;&amp;temp2.getY()&gt;<span class="number">0</span>&amp;&amp;temp2.getY()&lt;mainMap.getRow()&amp;&amp;nodeMap[temp2.getX()][temp2.getY()].getValue()==<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将四周的点都加入优先队列 算出所有FValue</span></span><br><span class="line">                    temp2.setGValue(start);</span><br><span class="line">                    temp2.setHValue(end);</span><br><span class="line"></span><br><span class="line">                    temp2.setPre(current.getId());</span><br><span class="line">                    nodeMap[temp2.getX()][temp2.getY()].setValue(-<span class="number">1</span>);</span><br><span class="line">                    open.add(temp2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">find2</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt;linkedList2=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        linkedList2.add(keptList.getLast());</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (linkedList2.get(j).getPre()!=-<span class="number">1</span>)&#123;</span><br><span class="line">            linkedList2.add(keptList.get(linkedList2.get(j).getPre()));</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        keptList=linkedList2;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title function_">find3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> time1=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        System.out.println(time1);</span><br><span class="line">        find();</span><br><span class="line">        find2();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> time2=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        System.out.println(time2);</span><br><span class="line">        System.out.println(time2-time1);</span><br><span class="line">        <span class="keyword">return</span> keptList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>绘图接口设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gallifrey.mazegame4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.Group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainPrint</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Group group;</span><br><span class="line">    <span class="keyword">protected</span> MainMap mainMap;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> OneCol;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> OneRow;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainPrint</span><span class="params">(Group group,MainMap mainMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.group = group;</span><br><span class="line">        <span class="built_in">this</span>.mainMap = mainMap;</span><br><span class="line">        OneCol=(<span class="type">double</span>) <span class="number">800</span> / mainMap.getCol();</span><br><span class="line">        OneRow=(<span class="type">double</span>) <span class="number">800</span>/mainMap.getRow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d）调试分析"><a href="#d）调试分析" class="headerlink" title="d）调试分析"></a>d）调试分析</h4><h5 id="开始界面（选择界面）"><a href="#开始界面（选择界面）" class="headerlink" title="开始界面（选择界面）"></a>开始界面（选择界面）</h5><p><img src="/posts/4fcdac8c8023/image-20220106044727148-16414156488732.png" alt="image-20220106044727148"></p><h5 id="Prim算法随机生成41-41迷宫"><a href="#Prim算法随机生成41-41迷宫" class="headerlink" title="Prim算法随机生成41*41迷宫"></a>Prim算法随机生成41*41迷宫</h5><p><img src="/posts/4fcdac8c8023/image-20220106044954737.png" alt="image-20220106044954737"></p><h5 id="DFS算法随机生成41-41迷宫"><a href="#DFS算法随机生成41-41迷宫" class="headerlink" title="DFS算法随机生成41*41迷宫"></a>DFS算法随机生成41*41迷宫</h5><p><img src="/posts/4fcdac8c8023/image-20220106045220105.png" alt="image-20220106045220105"></p><h5 id="路径规划（解迷宫）"><a href="#路径规划（解迷宫）" class="headerlink" title="路径规划（解迷宫）"></a>路径规划（解迷宫）</h5><p><img src="/posts/4fcdac8c8023/image-20220106045336440.png" alt="image-20220106045336440"></p><p><img src="/posts/4fcdac8c8023/image-20220106045056685-16414158585143.png" alt="image-20220106045056685"></p><h5 id="角色导航"><a href="#角色导航" class="headerlink" title="角色导航"></a>角色导航</h5><p><img src="/posts/4fcdac8c8023/image-20220106051028359.png" alt="image-20220106051028359"></p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>prim迷宫生成算法：原：O(n²)，使用优先队列改进：O(mlogn)</p><p>DFS迷宫生成算法：O(n²)</p><p>BFS路径规划算法：O(n²)</p><p>AStar路径规划算法：O（m*n）;m,n分别是地图的行数和列数</p><h2 id="项目二：手写计算器"><a href="#项目二：手写计算器" class="headerlink" title="项目二：手写计算器"></a>项目二：手写计算器</h2><h4 id="a-需求分析：-1"><a href="#a-需求分析：-1" class="headerlink" title="a)需求分析："></a>a)需求分析：</h4><h5 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h5><p>利用计算器实现一元多项式计算，表达式求值是实现程序设计语言的基本问题之一，栈的应用。设计一个程序，演示用算符优先法对算术表达式求值的过程。 </p><p>该计算器可以进行加减乘除，求余，阶乘，次方根的一元多项式计算</p><h4 id="b-概要设计：-1"><a href="#b-概要设计：-1" class="headerlink" title="b)概要设计："></a>b)概要设计：</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ul><li>利用栈将输入的算术式（中缀表达式）转逆波兰式（后缀表达式）</li><li>利用逆波兰式借助栈进行运算</li><li>实现基本的可视化以及用户交互功能</li></ul><h5 id="整体设计思路图"><a href="#整体设计思路图" class="headerlink" title="整体设计思路图"></a>整体设计思路图</h5><p><img src="/posts/4fcdac8c8023/io2.drawio.png" alt="io2.drawio"></p><h5 id="存储结构的设计"><a href="#存储结构的设计" class="headerlink" title="存储结构的设计"></a>存储结构的设计</h5><p><img src="/posts/4fcdac8c8023/io3.drawio.png" alt="io3.drawio"></p><h4 id="c）详细设计：-1"><a href="#c）详细设计：-1" class="headerlink" title="c）详细设计："></a>c）详细设计：</h4><h5 id="栈设计"><a href="#栈设计" class="headerlink" title="栈设计"></a>栈设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MaxSize=<span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">private</span> E data[];<span class="comment">//泛型+强制类型转换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top=-<span class="number">1</span>;<span class="comment">//栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        data=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[MaxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top==-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==MaxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[++top]=e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取栈顶符号</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getTop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="逆波兰式算法的实现"><a href="#逆波兰式算法的实现" class="headerlink" title="逆波兰式算法的实现"></a>逆波兰式算法的实现</h5><p>将一个普通的中缀表达式转换为<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">逆波兰表达式</a>的一般算法是：</p><p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为存放结果（逆波兰式）的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p><p>（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接送入S2栈。</p><p>（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符(不包括括号运算符)优先级高于S1栈栈顶运算符（包括左括号）优先级，则将该运算符进S1栈（或者栈空），否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入S1栈。</p><p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p><p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。</p><p>（5）重复上面的1~4步，直至处理完所有的输入字符。</p><p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p><h5 id="计算方法的实现"><a href="#计算方法的实现" class="headerlink" title="计算方法的实现"></a>计算方法的实现</h5><p>新建一个表达式,如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p><h5 id="计算器代码的设计-逆波兰式-计算方法"><a href="#计算器代码的设计-逆波兰式-计算方法" class="headerlink" title="计算器代码的设计:逆波兰式+计算方法"></a>计算器代码的设计:逆波兰式+计算方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> State;</span><br><span class="line">    MyStack &lt;Character&gt;tempStack;<span class="comment">//符号栈 临时栈</span></span><br><span class="line">    MyStack &lt;Character&gt;outStack2;<span class="comment">//    输出栈</span></span><br><span class="line">    MyStack &lt;String&gt; coutStack;<span class="comment">// 运算栈</span></span><br><span class="line">    String stringArr[];<span class="comment">//字符串数组</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    String suffix;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> &#123;</span><br><span class="line">        tempStack=<span class="keyword">new</span> <span class="title class_">MyStack</span>&lt;&gt;();</span><br><span class="line">        outStack2=<span class="keyword">new</span> <span class="title class_">MyStack</span>&lt;&gt;();</span><br><span class="line">        coutStack=<span class="keyword">new</span> <span class="title class_">MyStack</span>&lt;&gt;();</span><br><span class="line">        suffix=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        stringArr=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取优先级</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;%&#x27;</span> || c == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSuffix</span><span class="params">(<span class="type">char</span>[] input)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(input[i]!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//数字直接进输出栈</span></span><br><span class="line">            <span class="keyword">if</span>(input[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;input[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                outStack2.push(input[i++]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理运算符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input[i]==<span class="string">&#x27;+&#x27;</span>||input[i]==<span class="string">&#x27;-&#x27;</span>||input[i]==<span class="string">&#x27;*&#x27;</span>||input[i]==<span class="string">&#x27;/&#x27;</span>||input[i]==<span class="string">&#x27;!&#x27;</span>||input[i]==<span class="string">&#x27;%&#x27;</span>||input[i]==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//如果该运算符(不包括括号运算符)优先级高于tempStack栈栈顶运算符（包括左括号）优先级(或者栈空)，则将该运算符进tempStack栈</span></span><br><span class="line">                <span class="keyword">if</span>(tempStack.isEmpty()||tempStack.getTop()==<span class="string">&#x27;(&#x27;</span>||getState(input[i])&gt;getState(tempStack.getTop()))&#123;</span><br><span class="line">                    tempStack.push(input[i++]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，将tempStack栈的栈顶运算符弹出，送入outStack栈中，直至tempStack栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入outStack栈</span></span><br><span class="line">                    <span class="keyword">while</span>(!tempStack.isEmpty()&amp;&amp;getState(input[i])&lt;getState(tempStack.getTop()))&#123;</span><br><span class="line">                        outStack2.push(tempStack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    outStack2.push(tempStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若取出的字符是&#x27;(&#x27;，则直接入tempStack栈。</span></span><br><span class="line">            <span class="keyword">if</span> (input[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                tempStack.push(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若取出的字符是&#x27;)&#x27;，tempStack一直出栈到outStack栈中直到遇到 &#x27;(&#x27;,将&#x27;(&#x27;丢弃</span></span><br><span class="line">            <span class="keyword">if</span> (input[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(tempStack.getTop()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    outStack2.push(tempStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                tempStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!tempStack.isEmpty())&#123;</span><br><span class="line">            outStack2.push(tempStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuffix</span><span class="params">(String input)</span>&#123;</span><br><span class="line">        suffix=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.length();i++)&#123;</span><br><span class="line">            <span class="comment">//数字直接进输出栈 将数字变成浮点数类型</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i)&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;input.charAt(i)&lt;=<span class="string">&#x27;9&#x27;</span>||input.charAt(i)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                suffix += input.charAt(i);</span><br><span class="line"></span><br><span class="line">                String temp=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">                temp += input.charAt(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i+<span class="number">1</span>&lt;input.length()&amp;&amp;input.charAt(i+<span class="number">1</span>)&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;input.charAt(i+<span class="number">1</span>)&lt;=<span class="string">&#x27;9&#x27;</span>||i+<span class="number">1</span>&lt;input.length()&amp;&amp;input.charAt(i+<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    suffix += input.charAt(i+<span class="number">1</span>);</span><br><span class="line">                    temp += input.charAt(i+<span class="number">1</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                stringArr[j++]=temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理运算符</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(input.charAt(i)==<span class="string">&#x27;+&#x27;</span>||input.charAt(i)==<span class="string">&#x27;-&#x27;</span>||input.charAt(i)==<span class="string">&#x27;*&#x27;</span>||input.charAt(i)==<span class="string">&#x27;/&#x27;</span>||input.charAt(i)==<span class="string">&#x27;!&#x27;</span>||input.charAt(i)==<span class="string">&#x27;%&#x27;</span>||input.charAt(i)==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//如果该运算符(不包括括号运算符)优先级高于tempStack栈栈顶运算符（包括左括号）优先级(或者栈空)，则将该运算符进tempStack栈</span></span><br><span class="line">                <span class="keyword">if</span>(tempStack.isEmpty()||tempStack.getTop()==<span class="string">&#x27;(&#x27;</span>||getState(input.charAt(i))&gt;getState(tempStack.getTop()))&#123;</span><br><span class="line">                    tempStack.push(input.charAt(i));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则，将tempStack栈的栈顶运算符弹出，送入outStack栈中，直至tempStack栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入outStack栈</span></span><br><span class="line">                    <span class="keyword">while</span>(!tempStack.isEmpty()&amp;&amp;getState(input.charAt(i))&lt;getState(tempStack.getTop()))&#123;</span><br><span class="line">                        stringArr[j++]= String.valueOf(tempStack.getTop());</span><br><span class="line">                        suffix+=tempStack.pop();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    tempStack.push(input.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若取出的字符是&#x27;(&#x27;，则直接入tempStack栈。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               tempStack.push(input.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若取出的字符是&#x27;)&#x27;，tempStack一直出栈到outStack栈中直到遇到 &#x27;(&#x27;,将&#x27;(&#x27;丢弃</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(tempStack.getTop()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    stringArr[j++]= String.valueOf(tempStack.getTop());</span><br><span class="line">                    suffix+=(tempStack.pop());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                tempStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!tempStack.isEmpty())&#123;</span><br><span class="line">            stringArr[j++]= String.valueOf(tempStack.getTop());</span><br><span class="line">            suffix+=(tempStack.pop());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建一个表达式,如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= B+A;</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= B-A;</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= B*A;</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= B/A;</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;!&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">int</span> A= Integer.parseInt(coutStack.pop());</span><br><span class="line">                    <span class="type">int</span> B=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (A!=<span class="number">1</span>)&#123;</span><br><span class="line">                        B=B*A;</span><br><span class="line">                        A--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    coutStack.push(String.valueOf(B));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;%&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= B%A;</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringArr[i].equals(<span class="string">&quot;^&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">double</span> A= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> B= Double.parseDouble(coutStack.pop());</span><br><span class="line">                    <span class="type">double</span> C= Math.pow(B,A);</span><br><span class="line">                    coutStack.push(String.valueOf(C));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    coutStack.push(stringArr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        result= Double.parseDouble(coutStack.pop());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d）调试分析-1"><a href="#d）调试分析-1" class="headerlink" title="d）调试分析"></a>d）调试分析</h4><p>界面展示</p><p><img src="/posts/4fcdac8c8023/image-20220106054907661-16414193496586.png" alt="image-20220106054907661"></p><p>一元多项式运算</p><p><img src="/posts/4fcdac8c8023/image-20220106055136813.png" alt="image-20220106055136813"></p><p><img src="/posts/4fcdac8c8023/image-20220106055637698.png" alt="image-20220106055637698"></p><h2 id="项目三：猴子选大王-amp-Joseph环–可视化"><a href="#项目三：猴子选大王-amp-Joseph环–可视化" class="headerlink" title="项目三：猴子选大王&amp;Joseph环–可视化"></a>项目三：猴子选大王&amp;Joseph环–可视化</h2><h4 id="a-需求分析：-2"><a href="#a-需求分析：-2" class="headerlink" title="a)需求分析："></a>a)需求分析：</h4><h5 id="joseph"><a href="#joseph" class="headerlink" title="joseph"></a>joseph</h5><p>编号是1，2，„„,n的n个人按照顺时针方向围坐一圈，每个人只有一个密码（正整数）。一开始任选一个正整数作为报数上限值m,从第一个仍开始顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，将他的密码作为新的m值，从他在顺时针方向的下一个人开始重新从1报数，如此下去，直到所有人全                                 部出列为止。设计一个程序来求出出列顺序</p><h5 id="猴子选大王"><a href="#猴子选大王" class="headerlink" title="猴子选大王"></a>猴子选大王</h5><p>n只猴子围坐成一个圈，按顺时针方向从1到n编号。然后从1号猴子开始沿顺时针方向从1开始报数，报到m的猴子出局，再从刚出局猴子的下一个位置重新开始报数，如此重复，直至剩下一个猴子，它就是大王。设计并编写程序，实现如下功能：（1） 要求由用户输入开始时的猴子数n、报数的最后一个数m。（2） 给出当选猴王的初始编号。</p><h4 id="b-概要设计：-2"><a href="#b-概要设计：-2" class="headerlink" title="b)概要设计："></a>b)概要设计：</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>因为这两个题目比较相近，我写了在一起了，用一个可自定义的大小循环队列的解决一次解决，并将此过程可视化，添加用户交互。</p><h5 id="整体设计思路图-1"><a href="#整体设计思路图-1" class="headerlink" title="整体设计思路图"></a>整体设计思路图</h5><p><img src="/posts/4fcdac8c8023/io4.drawio-16414207490917.png" alt="io4.drawio"></p><p>在此说明每个部分的算法设计说明（可以是描述算法的流程图），每个程序中使用的存储结构设计说明（如果指定存储结构请写出该存储结构的定义）。</p><h5 id="存储结构的设计-1"><a href="#存储结构的设计-1" class="headerlink" title="存储结构的设计"></a>存储结构的设计</h5><p><img src="/posts/4fcdac8c8023/io5.drawio-16414220263348.png" alt="io5.drawio"></p><h4 id="c）详细设计：-2"><a href="#c）详细设计：-2" class="headerlink" title="c）详细设计："></a>c）详细设计：</h4><h5 id="循环队列设计"><a href="#循环队列设计" class="headerlink" title="循环队列设计"></a>循环队列设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.moneyking;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 手写循环队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySqQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Size;<span class="comment">//指定大小</span></span><br><span class="line">    E data[];<span class="comment">//泛型+强制类型转换</span></span><br><span class="line">    <span class="type">int</span> rear=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySqQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Size=(<span class="type">int</span>)<span class="number">1e6</span>;</span><br><span class="line">        data=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[Size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySqQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.Size = size;</span><br><span class="line">        data=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[Size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front==rear&amp;&amp;length==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((rear+<span class="number">1</span>)%Size==front)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队满了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear] = e;                <span class="comment">//进队</span></span><br><span class="line">        rear = (rear+<span class="number">1</span>)%Size;          <span class="comment">//尾指针+1</span></span><br><span class="line">        length++;                       <span class="comment">//长度+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> data[front];          <span class="comment">//出队元素</span></span><br><span class="line">        front = (front+<span class="number">1</span>)%data.length; <span class="comment">//头指针+1</span></span><br><span class="line">        length--;                 <span class="comment">//长度-1</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    MySqQueue&lt;Integer&gt; sqQueue=<span class="keyword">new</span> <span class="title class_">MySqQueue</span>&lt;&gt;(MoneyNumber+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//给每个猴子从1到n编号 全部进队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MoneyNumber;i++)&#123;</span><br><span class="line">        sqQueue.enqueue(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个计数器</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!sqQueue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> temp=sqQueue.dequeue();<span class="comment">//非空出队</span></span><br><span class="line">        System.out.print(temp+<span class="string">&quot; &quot;</span>);<span class="comment">//输出</span></span><br><span class="line">        count++;<span class="comment">//计数器+1</span></span><br><span class="line">        <span class="keyword">if</span>(count==index)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-------&quot;</span>+temp+<span class="string">&quot;出局&quot;</span>);</span><br><span class="line">           count=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!sqQueue.isEmpty())&#123;</span><br><span class="line">            sqQueue.enqueue(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d）调试分析-2"><a href="#d）调试分析-2" class="headerlink" title="d）调试分析"></a>d）调试分析</h4><h5 id="设置界面"><a href="#设置界面" class="headerlink" title="设置界面"></a>设置界面</h5><p><img src="/posts/4fcdac8c8023/image-20220106063719254-16414222408549.png" alt="image-20220106063719254"></p><h5 id="猴子选大王-1"><a href="#猴子选大王-1" class="headerlink" title="猴子选大王"></a>猴子选大王</h5><p><img src="/posts/4fcdac8c8023/image-20220106063752608-164142227383010.png" alt="image-20220106063752608"></p><p><img src="/posts/4fcdac8c8023/image-20220106063826976-164142230869811.png" alt="image-20220106063826976"></p><h5 id="joseph-1"><a href="#joseph-1" class="headerlink" title="joseph"></a>joseph</h5><p><img src="/posts/4fcdac8c8023/image-20220106063914161-164142235588812.png" alt="image-20220106063914161"></p><p><img src="/posts/4fcdac8c8023/image-20220106063928978-164142237056713-164142295756114.png" alt="image-20220106063928978"></p><h2 id="课设总结"><a href="#课设总结" class="headerlink" title="课设总结"></a>课设总结</h2><h5 id="课程设计过程的收获"><a href="#课程设计过程的收获" class="headerlink" title="课程设计过程的收获"></a>课程设计过程的收获</h5><p>这次数据结构课设，让我了解了很多算法的设计，很多数据结构的使用。在设计迷宫时我学习编写使用了队列，双端队列，优先队列，栈，链表，数值和广义表。利用prim算法生成迷宫其实是一个最小生成树也就是传说的完美迷宫，而DFS设计的迷宫则是利用了栈的递归回溯。而迷宫节点设计其实是参考了广义表的设计。在写A星路径规划算法时，则是设计使用了优先队列，通过比较总代价（当前路径+绝对路径）来确定路径方向。在设计计算机项目时，则是使用了栈后进先出的特点，来求解逆波兰式计算算式结果。最后是猴子选大王项目和joseph项目，则是使用了队列的先进先出特点，设计的算法。</p><h5 id="对数据结构这门课程的思考"><a href="#对数据结构这门课程的思考" class="headerlink" title="对数据结构这门课程的思考"></a>对数据结构这门课程的思考</h5><p>学习数据结构之前、一直以为数据结构是一门新的语言、后来才知道学习数据结构是为了更加高效的的组织数据、设计出良好的算法，而算法则是一个程序的灵魂。经过了一学期的数据结构了，在期末之际对其进行总结。首先，学完数据结构我们应该知道数据结构讲的是什么，数据结构课程主要是研究非数值计算的研究的程序设计问题中所出现的计算机处理对象以及它们之间关系和操作的学科。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目一：迷宫求解&quot;&gt;&lt;a href=&quot;#项目一：迷宫求解&quot; class=&quot;headerlink&quot; title=&quot;项目一：迷宫求解&quot;&gt;&lt;/a&gt;项目一：迷宫求解&lt;/h2&gt;&lt;h4 id=&quot;a-需求分析：&quot;&gt;&lt;a href=&quot;#a-需求分析：&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="课设报告" scheme="http://101.43.65.22/tags/%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>C++课设报告——工资管理系统</title>
    <link href="http://101.43.65.22/posts/c5b84aebdb34/"/>
    <id>http://101.43.65.22/posts/c5b84aebdb34/</id>
    <published>2021-12-30T22:38:22.000Z</published>
    <updated>2022-03-30T04:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h2><h3 id="1-1程序的基本功能"><a href="#1-1程序的基本功能" class="headerlink" title="1.1程序的基本功能"></a>1.1程序的基本功能</h3><h4 id="1-1-1-登陆功能"><a href="#1-1-1-登陆功能" class="headerlink" title="1.1.1 登陆功能"></a>1.1.1 登陆功能</h4><p>该系统设置了管理员登陆校验，只有输入正确的管理员账号和密码成功登陆才能进行相应的权限操作。</p><h4 id="1-1-2-查询功能"><a href="#1-1-2-查询功能" class="headerlink" title="1.1.2 查询功能"></a>1.1.2 查询功能</h4><p>该系统设置模糊（前模糊和后模糊）查找功能，可以根据职工编号快速找到相应的职工信息</p><h4 id="1-1-3-删除功能"><a href="#1-1-3-删除功能" class="headerlink" title="1.1.3 删除功能"></a>1.1.3 删除功能</h4><p>该系统具有删除职工工资信息功能</p><h4 id="1-1-4-新增表单功能"><a href="#1-1-4-新增表单功能" class="headerlink" title="1.1.4 新增表单功能"></a>1.1.4 新增表单功能</h4><p>该系统具有新增表单功能</p><h4 id="1-1-5-修改数据功能"><a href="#1-1-5-修改数据功能" class="headerlink" title="1.1.5 修改数据功能"></a>1.1.5 修改数据功能</h4><p>该系统可方便更改数据    </p><h4 id="1-1-6账目自动统计"><a href="#1-1-6账目自动统计" class="headerlink" title="1.1.6账目自动统计"></a>1.1.6账目自动统计</h4><p>该系统会自动统计职工的每月工资，应发数，个人所得税，实发数，并确保计算所得数据准确且无法被人为修改。</p><h3 id="1-2其他功能"><a href="#1-2其他功能" class="headerlink" title="1.2其他功能"></a>1.2其他功能</h3><h4 id="1-2-1信息安全"><a href="#1-2-1信息安全" class="headerlink" title="1.2.1信息安全"></a>1.2.1信息安全</h4><p>该系统将信息保存在本地的文件类型数据库SQLite中，确保数据安全。</p><h4 id="1-2-2可视化界面"><a href="#1-2-2可视化界面" class="headerlink" title="1.2.2可视化界面"></a>1.2.2可视化界面</h4><p>该系统具有美观，易读，易操作的可视化界面</p><h4 id="1-2-3动画效果"><a href="#1-2-3动画效果" class="headerlink" title="1.2.3动画效果"></a>1.2.3动画效果</h4><p>部分组件增加动画效果，提高观赏性</p><h2 id="2-课题的分析"><a href="#2-课题的分析" class="headerlink" title="2    课题的分析"></a>2    课题的分析</h2><h3 id="2-1-图形化界面开发框架选择"><a href="#2-1-图形化界面开发框架选择" class="headerlink" title="2.1    图形化界面开发框架选择"></a>2.1    图形化界面开发框架选择</h3><p>考虑到是给用户使用的工资管理系统，我认为可视化的界面是必不可少的。因为C++的标准库中并没有包含GUI，我只能从第三方C++图形化界面开发库中选择。最终我选择了Qt，因为Qt是一个比较老的C++图形界面开发框架，各种功能都比较完善，问题解决方法也比较多，有优秀的跨平台性。而且集成开发工具和跨平台的IDE，可视化地图形化界面设计，可以减少很多前端学习成本。</p><h3 id="2-2-数据库选择"><a href="#2-2-数据库选择" class="headerlink" title="2.2    数据库选择"></a>2.2    数据库选择</h3><p>考虑要存储数据，我第一时间想到的就是数据库。我最初想使用mysql数据库的，因为我个人对MySQL数据库比熟悉，而且mysql数据库配合navicat可以极大加快我的开发效率。但是因为Qt对MySQL的驱动支持问题（mysql版本太多），最终还是使用Qt自带的数据库SQLite。SQLite是一款轻型的数据库，它的设计目标是嵌入式的，而且已经在很多嵌入式产品中使用了它，它占用资源非常的低。</p><h3 id="2-3-MVC模式"><a href="#2-3-MVC模式" class="headerlink" title="2.3   MVC模式"></a>2.3   MVC模式</h3><p>这次课程设计，我打算用mvc模式来写。将视图，模型，控制器和业务逻辑等分离出来。但是毕竟是一个C++的课设，而我又从未接触过Qt，所以可能只是尽可能往mvc模式方向设计。但并不能说严格地像springboot一样规范。</p><h2 id="3-详细设计"><a href="#3-详细设计" class="headerlink" title="3    详细设计"></a>3    详细设计</h2><h3 id="3-1-数据库设计"><a href="#3-1-数据库设计" class="headerlink" title="3.1    数据库设计"></a>3.1    数据库设计</h3><p><img src="/posts/c5b84aebdb34/image-20211231073900186-16409075427701.png" alt="image-20211231073900186"></p><p>EmpMoney（职工工资）就是我这次用到的数据库表，SQLite只有4种数据类型，除了表主键id，职工编号empID外，其余用于计算工资的数值类型均选择了与double亲和类型最近的real类型</p><table><thead><tr><th align="left">亲和类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">TEXT</td><td align="left">数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。</td></tr><tr><td align="left">NUMERIC</td><td align="left">当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如”30000.0”，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。</td></tr><tr><td align="left">INTEGER</td><td align="left">对于亲缘类型为INTEGER的字段，其规则等同于NUMERIC，唯一差别是在执行CAST表达式时。</td></tr><tr><td align="left">REAL</td><td align="left">其规则基本等同于NUMERIC，唯一的差别是不会将”30000.0”这样的文本数据转换为INTEGER存储方式。</td></tr><tr><td align="left">NONE</td><td align="left">不做任何的转换，直接以该数据所属的数据类型进行存储。</td></tr></tbody></table><h3 id="3-2-实体类模型设计"><a href="#3-2-实体类模型设计" class="headerlink" title="3.2    实体类模型设计"></a>3.2    实体类模型设计</h3><p><img src="/posts/c5b84aebdb34/image-20211231075318560-16409084000922.png" alt="image-20211231075318560"></p><p>数据中所有职工工资映射的实体类</p><h3 id="3-3-数据库连接层设计"><a href="#3-3-数据库连接层设计" class="headerlink" title="3.3    数据库连接层设计"></a>3.3    数据库连接层设计</h3><p><img src="/posts/c5b84aebdb34/image-20211231075430040-16409084717213.png" alt="image-20211231075430040"></p><p>LinkSQLite类的设计，用于连接数据，编写SQLite的sql语句，数据库的增删改查得以实现</p><h3 id="3-4-控制器和视图交互"><a href="#3-4-控制器和视图交互" class="headerlink" title="3.4    控制器和视图交互"></a>3.4    控制器和视图交互</h3><p><img src="/posts/c5b84aebdb34/image-20211231075645138-16409086071364.png" alt="image-20211231075645138"></p><p>视图层和控制器合二为一 了，删去冗余的业务逻辑层，在mainwindow完成了模型和视图的交互，并处理业务逻辑。</p><h2 id="4-课程设计总结"><a href="#4-课程设计总结" class="headerlink" title="4    课程设计总结"></a>4    课程设计总结</h2><h3 id="4-1-完成情况"><a href="#4-1-完成情况" class="headerlink" title="4.1    完成情况"></a>4.1    完成情况</h3><h4 id="4-1-1登陆功能"><a href="#4-1-1登陆功能" class="headerlink" title="4.1.1登陆功能"></a>4.1.1登陆功能</h4><p>1.登陆失败提醒 （管理员初始账号密码均为:admin）</p><p><img src="/posts/c5b84aebdb34/image-20211231075929729-16409087715345.png" alt="image-20211231075929729"></p><p>2.登陆成功显示所有职工工资信息</p><p><img src="/posts/c5b84aebdb34/image-20211231080924094-164090936582010.png" alt="image-20211231080924094"></p><h4 id="4-1-2查询功能"><a href="#4-1-2查询功能" class="headerlink" title="4.1.2查询功能"></a>4.1.2查询功能</h4><p>1.精确查询  （登陆页面提供折叠功能，已经折叠）</p><p><img src="/posts/c5b84aebdb34/image-20211231080419776-16409090618328.png" alt="image-20211231080419776"></p><p>2.模糊查询</p><p><img src="/posts/c5b84aebdb34/image-20211231080628305-16409091900989.png" alt="image-20211231080628305"></p><h4 id="4-1-3删除功能"><a href="#4-1-3删除功能" class="headerlink" title="4.1.3删除功能"></a>4.1.3删除功能</h4><p><img src="/posts/c5b84aebdb34/image-20211231081053441-164090945580411.png" alt="image-20211231081053441"></p><p><img src="/posts/c5b84aebdb34/image-20211231081106889.png" alt="image-20211231081106889"></p><p><img src="/posts/c5b84aebdb34/image-20211231081116856.png" alt="image-20211231081116856"></p><h4 id="4-1-3新增表单功能"><a href="#4-1-3新增表单功能" class="headerlink" title="4.1.3新增表单功能"></a>4.1.3新增表单功能</h4><p>1.点击查找旁边的增加表单按钮 进入新增表单页面</p><p><img src="/posts/c5b84aebdb34/image-20211231081213874-164090953660712.png" alt="image-20211231081213874"></p><p>2.填写并提交</p><p><img src="/posts/c5b84aebdb34/image-20211231081635985-164090979750414.png" alt="image-20211231081635985"></p><p>3.自动计算工资税务，应发数，实发数</p><p><img src="/posts/c5b84aebdb34/image-20211231081701713-164090982304515.png" alt="image-20211231081701713"></p><p>4.14修改</p><p><img src="/posts/c5b84aebdb34/image-20211231081858674-164090994025416.png" alt="image-20211231081858674"></p><p><img src="/posts/c5b84aebdb34/image-20211231081913857-164090995552617.png" alt="image-20211231081913857"></p><p><img src="/posts/c5b84aebdb34/image-20211231081937034.png" alt="image-20211231081937034"></p><h3 id="4-2-遇到的问题及解决"><a href="#4-2-遇到的问题及解决" class="headerlink" title="4.2    遇到的问题及解决"></a>4.2    遇到的问题及解决</h3><p>​    SQLite字符串传参多次失效，改用Qt的字符串类型QString，情况极大改善。</p><p>​    添加数据的输入文本框设计时，数据库连接中断，程序崩坏。后查明是io流阻塞问题，采用单窗口解决了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">SQLite 教程 | 菜鸟教程 (runoob.cohttps://www.runoob.com/sqlite/sqlite-tutorial.htmlm)</a></p><p><a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p><p>2.<a href="https://www.qt.io/design">User Interface Design Toolshttps://www.qt.io/design | The Best UI Design Software | Qt Designer | Qt</a></p><p>3.<a href="https://blog.csdn.net/qq_42243240/article/details/110951793">(21条消息) Qt主线程阻塞导致消息队列中的uart动作处理不及时(处理耗时操作导致界面卡顿)_我金啊的博客-CSDN博客_qt主线程被阻塞</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1    概述&quot;&gt;&lt;/a&gt;1    概述&lt;/h2&gt;&lt;h3 id=&quot;1-1程序的基本功能&quot;&gt;&lt;a href=&quot;#1-1程序的基本功能&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="课设报告" scheme="http://101.43.65.22/tags/%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>Java框架课设报告</title>
    <link href="http://101.43.65.22/posts/66f755d23c96/"/>
    <id>http://101.43.65.22/posts/66f755d23c96/</id>
    <published>2021-12-11T15:45:56.000Z</published>
    <updated>2022-03-30T04:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MFMF花卉交易平台设计报告"><a href="#MFMF花卉交易平台设计报告" class="headerlink" title="MFMF花卉交易平台设计报告"></a>MFMF花卉交易平台设计报告</h1><h2 id="1-框架介绍"><a href="#1-框架介绍" class="headerlink" title="1.框架介绍"></a>1.框架介绍</h2><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><em><strong>Vue</strong></em></h3><p><strong>Vue</strong> 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="SringBoot"><a href="#SringBoot" class="headerlink" title="SringBoot"></a><em>SringBoot</em></h3><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><em><strong>MyBatis</strong></em></h3><p><strong>MyBatis</strong> 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a><em>Lombok</em></h3><p><strong>Lombok</strong>框架是用于简化代码编写的框架，在项目中编写实体类、VO类等类时，都会为属性添<br>加SETTERS &amp; GETTERS方法，重新生成 toString() ，保留无参数构造方法，生成 hashCode()<br>和 equals() ……Lombok框架只需要使用一些注解即可在编译时插入这些方法，则编写代码时<br>只需要声明属性并添加注解即可</p><h2 id="2-系统名称"><a href="#2-系统名称" class="headerlink" title="2. 系统名称"></a>2. 系统名称</h2><p><strong>MFMF花卉交易平台</strong></p><p>MFMF是my flowers my friends的简写，MFMF花卉交易平台（下面简称MFMF平台）是用于设计给管理员管理用户和用户交易虚拟花卉（MFMF flower）的系统平台。</p><p>管理员用户可以在MFMF平台上实现对普通用户的处理（查询用户，新建用户，修改用户信息，封禁用户，删除用户）。</p><p>MFMF用户在注册时将在四种MFMF虚拟花种（MFMF virtual flower seed）中选择一份初始花种，和免费获得5花币（MFMF coin）作为自己的初始财产。</p><p>用户可以在MFMF平台培育场模块中选择一片MFMF地区栽种MFMF花种，该地区将以真实的地区实时气候以及和花种的适应性来决定MFMF虚拟花卉的成长期，在MFMF虚拟花卉成熟后，用户将获取该虚拟花卉和诺干该花卉的花种作为自己的资产。</p><p>不同的诺干个虚拟花种栽种在相同地区，气候适合的情况下有一定概率产生新的杂交变种花种，以此培育新的MFMF花卉。</p><p>用户可以在MFMF平台上的交易所中和其他用户用花币交易虚拟花种（MFMF flower seed）和MFMF虚拟花卉，在此过程中平台将收取00.1%的花币作为手续费用。用户购买或栽种得来的MFMF花卉可以在MFMF平台的展示厅模块进行展示。</p><h2 id="3．应用的框架"><a href="#3．应用的框架" class="headerlink" title="3．应用的框架"></a>3．应用的框架</h2><p> <strong>以下是我选择的框架及其原因：</strong></p><h3 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h3><p><strong>Vue</strong> 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="SringBoot-1"><a href="#SringBoot-1" class="headerlink" title="SringBoot"></a><em>SringBoot</em></h3><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><h3 id="MyBatis-1"><a href="#MyBatis-1" class="headerlink" title="MyBatis"></a><em><strong>MyBatis</strong></em></h3><p><strong>MyBatis</strong> 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h3 id="Lombok-1"><a href="#Lombok-1" class="headerlink" title="Lombok"></a><em>Lombok</em></h3><p><strong>Lombok</strong>框架是用于简化代码编写的框架，在项目中编写实体类、VO类等类时，都会为属性添<br>加SETTERS &amp; GETTERS方法，重新生成 toString() ，保留无参数构造方法，生成 hashCode()<br>和 equals() ……Lombok框架只需要使用一些注解即可在编译时插入这些方法，则编写代码时<br>只需要声明属性并添加注解即可</p><h2 id="4．项目目录和文件名的截图"><a href="#4．项目目录和文件名的截图" class="headerlink" title="4．项目目录和文件名的截图"></a>4．项目目录和文件名的截图</h2><h3 id="文件名："><a href="#文件名：" class="headerlink" title="文件名："></a>文件名：</h3><p><img src="/posts/66f755d23c96/clip_image002.png" alt="img"><img src="/posts/66f755d23c96/clip_image003.png" alt="img"></p><p><img src="/posts/66f755d23c96/image-20211211235457282.png" alt="image-20211211235457282"></p><p><img src="/posts/66f755d23c96/image-20211211235558614.png" alt="image-20211211235558614"></p><h3 id="Springboot项目目录结构："><a href="#Springboot项目目录结构：" class="headerlink" title="Springboot项目目录结构："></a>Springboot项目目录结构：</h3><p><img src="/posts/66f755d23c96/clip_image005.jpg" alt="img"></p><h3 id="Vue项目目录结构："><a href="#Vue项目目录结构：" class="headerlink" title="Vue项目目录结构："></a>Vue项目目录结构：</h3><p><img src="/posts/66f755d23c96/clip_image007.jpg" alt="img"></p><h2 id="5．主要文件的内容截图"><a href="#5．主要文件的内容截图" class="headerlink" title="5．主要文件的内容截图"></a>5．主要文件的内容截图</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p><img src="/posts/66f755d23c96/clip_image009.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image011.jpg" alt="img"></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><img src="/posts/66f755d23c96/clip_image013.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image015.jpg" alt="img"></p><h2 id="6．功能模块实现"><a href="#6．功能模块实现" class="headerlink" title="6．功能模块实现"></a>6．功能模块实现</h2><ol><li>登陆页面</li><li>用户列表</li><li>安全退出按钮</li><li>添加用户按钮</li><li>查询用户框</li><li>修改用户信息按钮</li><li>改变用户状态按钮</li><li>删除用户按钮</li></ol><h2 id="7．功能模块的描述"><a href="#7．功能模块的描述" class="headerlink" title="7．功能模块的描述"></a>7．功能模块的描述</h2><ol><li>登陆页面：用户&#x2F;管理员登陆</li><li>用户列表：分页并显示所有用户</li><li>安全退出按钮：清除Session中储存的用户信息</li><li>添加用户按钮：实现添加用户</li><li>查询用户框：通过用户名或者昵称查询用户</li><li>修改用户信息按钮：修改用户信息</li><li>改变用户状态按钮：改变用户状态</li><li>删除用户按钮：删除用户</li></ol><h2 id="8．功能实现的截图"><a href="#8．功能实现的截图" class="headerlink" title="8．功能实现的截图"></a>8．功能实现的截图</h2><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3><p><img src="/posts/66f755d23c96/clip_image017.jpg" alt="img"></p><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p><img src="/posts/66f755d23c96/clip_image019.jpg" alt="img"></p><h3 id="用户列表"><a href="#用户列表" class="headerlink" title="用户列表"></a>用户列表</h3><p><img src="/posts/66f755d23c96/clip_image021.jpg" alt="img"></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><img src="/posts/66f755d23c96/clip_image023.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image025.jpg" alt="img"></p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p><img src="/posts/66f755d23c96/clip_image027.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image028.png" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image030.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image032.jpg" alt="img"></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><img src="/posts/66f755d23c96/clip_image033.png" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image035.jpg" alt="img"></p><p><img src="/posts/66f755d23c96/clip_image037.jpg" alt="img"></p><h3 id="改变用户状态"><a href="#改变用户状态" class="headerlink" title="改变用户状态"></a>改变用户状态</h3><p><img src="/posts/66f755d23c96/image-20211212000733830.png" alt="image-20211212000733830"></p><p><img src="/posts/66f755d23c96/image-20211212000808308.png" alt="image-20211212000808308"></p><p><img src="/posts/66f755d23c96/image-20211212000828854.png" alt="image-20211212000828854"></p><h2 id="9．相关代码截图"><a href="#9．相关代码截图" class="headerlink" title="9．相关代码截图"></a>9．相关代码截图</h2><p><img src="/posts/66f755d23c96/image-20211212001658380.png" alt="image-20211212001658380"></p><p><img src="/posts/66f755d23c96/image-20211212001718416.png" alt="image-20211212001718416"></p><p><img src="/posts/66f755d23c96/image-20211212001738941.png" alt="image-20211212001738941"></p><p><img src="/posts/66f755d23c96/image-20211212001748493.png" alt="image-20211212001748493"></p><p><img src="/posts/66f755d23c96/image-20211212001756912.png" alt="image-20211212001756912"></p><p><img src="/posts/66f755d23c96/image-20211212001816613.png" alt="image-20211212001816613"></p><p><img src="/posts/66f755d23c96/image-20211212001840482.png" alt="image-20211212001840482"></p><p><img src="/posts/66f755d23c96/image-20211212001849144.png" alt="image-20211212001849144"></p><p><img src="/posts/66f755d23c96/image-20211212001903606.png" alt="image-20211212001903606"></p><p><img src="/posts/66f755d23c96/image-20211212001922247.png" alt="image-20211212001922247"></p><h2 id="10．结束语"><a href="#10．结束语" class="headerlink" title="10．结束语"></a>10．结束语</h2><p>这次大作业是我写的第一个前后端分离的项目，实话实说开发大部分时间都花在了学习前端vue语言和处理前后端跨越问题上了。这次Vue中用到异步的方法真的让我很吃惊，惊叹于前端语言的发展已经如此完善了，但是跨域问题依旧很难处理。虽然这次大作业结束了。但是MFMF花卉平台的开发还远远没有结束。在将来我将逐步和完善实现MFMF平台设计之初设计的功能。在将MFMF平台完善到一定的程度后，我将会把这个平台放上服务器，让大家可以真正使用到这个平台来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MFMF花卉交易平台设计报告&quot;&gt;&lt;a href=&quot;#MFMF花卉交易平台设计报告&quot; class=&quot;headerlink&quot; title=&quot;MFMF花卉交易平台设计报告&quot;&gt;&lt;/a&gt;MFMF花卉交易平台设计报告&lt;/h1&gt;&lt;h2 id=&quot;1-框架介绍&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="课设报告" scheme="http://101.43.65.22/tags/%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
</feed>
